// Autogenerated by Thrift Compiler (0.14.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TProtocolVersion {
  HiveCliServiceProtocolV1 = 0,
  HiveCliServiceProtocolV2 = 1,
  HiveCliServiceProtocolV3 = 2,
  HiveCliServiceProtocolV4 = 3,
  HiveCliServiceProtocolV5 = 4,
  HiveCliServiceProtocolV6 = 5,
  HiveCliServiceProtocolV7 = 6,
  HiveCliServiceProtocolV8 = 7,
  HiveCliServiceProtocolV9 = 8,
  HiveCliServiceProtocolV10 = 9,
  HiveCliServiceProtocolV11 = 10,
}

impl TProtocolVersion {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TProtocolVersion> {
    let enum_value = i_prot.read_i32()?;
    TProtocolVersion::try_from(enum_value)  }
}

impl TryFrom<i32> for TProtocolVersion {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TProtocolVersion::HiveCliServiceProtocolV1),
      1 => Ok(TProtocolVersion::HiveCliServiceProtocolV2),
      2 => Ok(TProtocolVersion::HiveCliServiceProtocolV3),
      3 => Ok(TProtocolVersion::HiveCliServiceProtocolV4),
      4 => Ok(TProtocolVersion::HiveCliServiceProtocolV5),
      5 => Ok(TProtocolVersion::HiveCliServiceProtocolV6),
      6 => Ok(TProtocolVersion::HiveCliServiceProtocolV7),
      7 => Ok(TProtocolVersion::HiveCliServiceProtocolV8),
      8 => Ok(TProtocolVersion::HiveCliServiceProtocolV9),
      9 => Ok(TProtocolVersion::HiveCliServiceProtocolV10),
      10 => Ok(TProtocolVersion::HiveCliServiceProtocolV11),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TProtocolVersion", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TTypeId {
  BooleanType = 0,
  TinyintType = 1,
  SmallintType = 2,
  IntType = 3,
  BigintType = 4,
  FloatType = 5,
  DoubleType = 6,
  StringType = 7,
  TimestampType = 8,
  BinaryType = 9,
  ArrayType = 10,
  MapType = 11,
  StructType = 12,
  UnionType = 13,
  UserDefinedType = 14,
  DecimalType = 15,
  NullType = 16,
  DateType = 17,
  VarcharType = 18,
  CharType = 19,
  IntervalYearMonthType = 20,
  IntervalDayTimeType = 21,
  TimestamplocaltzType = 22,
}

impl TTypeId {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeId> {
    let enum_value = i_prot.read_i32()?;
    TTypeId::try_from(enum_value)  }
}

impl TryFrom<i32> for TTypeId {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TTypeId::BooleanType),
      1 => Ok(TTypeId::TinyintType),
      2 => Ok(TTypeId::SmallintType),
      3 => Ok(TTypeId::IntType),
      4 => Ok(TTypeId::BigintType),
      5 => Ok(TTypeId::FloatType),
      6 => Ok(TTypeId::DoubleType),
      7 => Ok(TTypeId::StringType),
      8 => Ok(TTypeId::TimestampType),
      9 => Ok(TTypeId::BinaryType),
      10 => Ok(TTypeId::ArrayType),
      11 => Ok(TTypeId::MapType),
      12 => Ok(TTypeId::StructType),
      13 => Ok(TTypeId::UnionType),
      14 => Ok(TTypeId::UserDefinedType),
      15 => Ok(TTypeId::DecimalType),
      16 => Ok(TTypeId::NullType),
      17 => Ok(TTypeId::DateType),
      18 => Ok(TTypeId::VarcharType),
      19 => Ok(TTypeId::CharType),
      20 => Ok(TTypeId::IntervalYearMonthType),
      21 => Ok(TTypeId::IntervalDayTimeType),
      22 => Ok(TTypeId::TimestamplocaltzType),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TTypeId", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TStatusCode {
  SuccessStatus = 0,
  SuccessWithInfoStatus = 1,
  StillExecutingStatus = 2,
  ErrorStatus = 3,
  InvalidHandleStatus = 4,
}

impl TStatusCode {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStatusCode> {
    let enum_value = i_prot.read_i32()?;
    TStatusCode::try_from(enum_value)  }
}

impl TryFrom<i32> for TStatusCode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TStatusCode::SuccessStatus),
      1 => Ok(TStatusCode::SuccessWithInfoStatus),
      2 => Ok(TStatusCode::StillExecutingStatus),
      3 => Ok(TStatusCode::ErrorStatus),
      4 => Ok(TStatusCode::InvalidHandleStatus),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TStatusCode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TOperationState {
  InitializedState = 0,
  RunningState = 1,
  FinishedState = 2,
  CanceledState = 3,
  ClosedState = 4,
  ErrorState = 5,
  UknownState = 6,
  PendingState = 7,
  TimedoutState = 8,
}

impl TOperationState {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOperationState> {
    let enum_value = i_prot.read_i32()?;
    TOperationState::try_from(enum_value)  }
}

impl TryFrom<i32> for TOperationState {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TOperationState::InitializedState),
      1 => Ok(TOperationState::RunningState),
      2 => Ok(TOperationState::FinishedState),
      3 => Ok(TOperationState::CanceledState),
      4 => Ok(TOperationState::ClosedState),
      5 => Ok(TOperationState::ErrorState),
      6 => Ok(TOperationState::UknownState),
      7 => Ok(TOperationState::PendingState),
      8 => Ok(TOperationState::TimedoutState),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TOperationState", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TOperationType {
  ExecuteStatement = 0,
  GetTypeInfo = 1,
  GetCatalogs = 2,
  GetSchemas = 3,
  GetTables = 4,
  GetTableTypes = 5,
  GetColumns = 6,
  GetFunctions = 7,
  Unknown = 8,
}

impl TOperationType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOperationType> {
    let enum_value = i_prot.read_i32()?;
    TOperationType::try_from(enum_value)  }
}

impl TryFrom<i32> for TOperationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TOperationType::ExecuteStatement),
      1 => Ok(TOperationType::GetTypeInfo),
      2 => Ok(TOperationType::GetCatalogs),
      3 => Ok(TOperationType::GetSchemas),
      4 => Ok(TOperationType::GetTables),
      5 => Ok(TOperationType::GetTableTypes),
      6 => Ok(TOperationType::GetColumns),
      7 => Ok(TOperationType::GetFunctions),
      8 => Ok(TOperationType::Unknown),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TOperationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TGetInfoType {
  CliMaxDriverConnections = 0,
  CliMaxConcurrentActivities = 1,
  CliDataSourceName = 2,
  CliFetchDirection = 8,
  CliServerName = 13,
  CliSearchPatternEscape = 14,
  CliDbmsName = 17,
  CliDbmsVer = 18,
  CliAccessibleTables = 19,
  CliAccessibleProcedures = 20,
  CliCursorCommitBehavior = 23,
  CliDataSourceReadOnly = 25,
  CliDefaultTxnIsolation = 26,
  CliIdentifierCase = 28,
  CliIdentifierQuoteChar = 29,
  CliMaxColumnNameLen = 30,
  CliMaxCursorNameLen = 31,
  CliMaxSchemaNameLen = 32,
  CliMaxCatalogNameLen = 34,
  CliMaxTableNameLen = 35,
  CliScrollConcurrency = 43,
  CliTxnCapable = 46,
  CliUserName = 47,
  CliTxnIsolationOption = 72,
  CliIntegrity = 73,
  CliGetdataExtensions = 81,
  CliNullCollation = 85,
  CliAlterTable = 86,
  CliOrderByColumnsInSelect = 90,
  CliSpecialCharacters = 94,
  CliMaxColumnsInGroupBy = 97,
  CliMaxColumnsInIndex = 98,
  CliMaxColumnsInOrderBy = 99,
  CliMaxColumnsInSelect = 100,
  CliMaxColumnsInTable = 101,
  CliMaxIndexSize = 102,
  CliMaxRowSize = 104,
  CliMaxStatementLen = 105,
  CliMaxTablesInSelect = 106,
  CliMaxUserNameLen = 107,
  CliOjCapabilities = 115,
  CliXopenCliYear = 10000,
  CliCursorSensitivity = 10001,
  CliDescribeParameter = 10002,
  CliCatalogName = 10003,
  CliCollationSeq = 10004,
  CliMaxIdentifierLen = 10005,
  CliOdbcKeywords = 10006,
}

impl TGetInfoType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetInfoType> {
    let enum_value = i_prot.read_i32()?;
    TGetInfoType::try_from(enum_value)  }
}

impl TryFrom<i32> for TGetInfoType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TGetInfoType::CliMaxDriverConnections),
      1 => Ok(TGetInfoType::CliMaxConcurrentActivities),
      2 => Ok(TGetInfoType::CliDataSourceName),
      8 => Ok(TGetInfoType::CliFetchDirection),
      13 => Ok(TGetInfoType::CliServerName),
      14 => Ok(TGetInfoType::CliSearchPatternEscape),
      17 => Ok(TGetInfoType::CliDbmsName),
      18 => Ok(TGetInfoType::CliDbmsVer),
      19 => Ok(TGetInfoType::CliAccessibleTables),
      20 => Ok(TGetInfoType::CliAccessibleProcedures),
      23 => Ok(TGetInfoType::CliCursorCommitBehavior),
      25 => Ok(TGetInfoType::CliDataSourceReadOnly),
      26 => Ok(TGetInfoType::CliDefaultTxnIsolation),
      28 => Ok(TGetInfoType::CliIdentifierCase),
      29 => Ok(TGetInfoType::CliIdentifierQuoteChar),
      30 => Ok(TGetInfoType::CliMaxColumnNameLen),
      31 => Ok(TGetInfoType::CliMaxCursorNameLen),
      32 => Ok(TGetInfoType::CliMaxSchemaNameLen),
      34 => Ok(TGetInfoType::CliMaxCatalogNameLen),
      35 => Ok(TGetInfoType::CliMaxTableNameLen),
      43 => Ok(TGetInfoType::CliScrollConcurrency),
      46 => Ok(TGetInfoType::CliTxnCapable),
      47 => Ok(TGetInfoType::CliUserName),
      72 => Ok(TGetInfoType::CliTxnIsolationOption),
      73 => Ok(TGetInfoType::CliIntegrity),
      81 => Ok(TGetInfoType::CliGetdataExtensions),
      85 => Ok(TGetInfoType::CliNullCollation),
      86 => Ok(TGetInfoType::CliAlterTable),
      90 => Ok(TGetInfoType::CliOrderByColumnsInSelect),
      94 => Ok(TGetInfoType::CliSpecialCharacters),
      97 => Ok(TGetInfoType::CliMaxColumnsInGroupBy),
      98 => Ok(TGetInfoType::CliMaxColumnsInIndex),
      99 => Ok(TGetInfoType::CliMaxColumnsInOrderBy),
      100 => Ok(TGetInfoType::CliMaxColumnsInSelect),
      101 => Ok(TGetInfoType::CliMaxColumnsInTable),
      102 => Ok(TGetInfoType::CliMaxIndexSize),
      104 => Ok(TGetInfoType::CliMaxRowSize),
      105 => Ok(TGetInfoType::CliMaxStatementLen),
      106 => Ok(TGetInfoType::CliMaxTablesInSelect),
      107 => Ok(TGetInfoType::CliMaxUserNameLen),
      115 => Ok(TGetInfoType::CliOjCapabilities),
      10000 => Ok(TGetInfoType::CliXopenCliYear),
      10001 => Ok(TGetInfoType::CliCursorSensitivity),
      10002 => Ok(TGetInfoType::CliDescribeParameter),
      10003 => Ok(TGetInfoType::CliCatalogName),
      10004 => Ok(TGetInfoType::CliCollationSeq),
      10005 => Ok(TGetInfoType::CliMaxIdentifierLen),
      10006 => Ok(TGetInfoType::CliOdbcKeywords),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TGetInfoType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TFetchOrientation {
  FetchNext = 0,
  FetchPrior = 1,
  FetchRelative = 2,
  FetchAbsolute = 3,
  FetchFirst = 4,
  FetchLast = 5,
}

impl TFetchOrientation {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFetchOrientation> {
    let enum_value = i_prot.read_i32()?;
    TFetchOrientation::try_from(enum_value)  }
}

impl TryFrom<i32> for TFetchOrientation {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TFetchOrientation::FetchNext),
      1 => Ok(TFetchOrientation::FetchPrior),
      2 => Ok(TFetchOrientation::FetchRelative),
      3 => Ok(TFetchOrientation::FetchAbsolute),
      4 => Ok(TFetchOrientation::FetchFirst),
      5 => Ok(TFetchOrientation::FetchLast),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TFetchOrientation", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TJobExecutionStatus {
  InProgress = 0,
  Complete = 1,
  NotAvailable = 2,
}

impl TJobExecutionStatus {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJobExecutionStatus> {
    let enum_value = i_prot.read_i32()?;
    TJobExecutionStatus::try_from(enum_value)  }
}

impl TryFrom<i32> for TJobExecutionStatus {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TJobExecutionStatus::InProgress),
      1 => Ok(TJobExecutionStatus::Complete),
      2 => Ok(TJobExecutionStatus::NotAvailable),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TJobExecutionStatus", i)
            )
          )
        )
      },
    }
  }
}

pub type TTypeEntryPtr = i32;

pub type TIdentifier = String;

pub type TPattern = String;

pub type TPatternOrIdentifier = String;

//
// TTypeQualifierValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TTypeQualifierValue {
  I32Value(i32),
  StringValue(String),
}

impl TTypeQualifierValue {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeQualifierValue> {
    let mut ret: Option<TTypeQualifierValue> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          if ret.is_none() {
            ret = Some(TTypeQualifierValue::I32Value(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = i_prot.read_string()?;
          if ret.is_none() {
            ret = Some(TTypeQualifierValue::StringValue(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TTypeQualifierValue"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TTypeQualifierValue"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTypeQualifierValue");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TTypeQualifierValue::I32Value(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("i32Value", TType::I32, 1))?;
        o_prot.write_i32(f)?;
        o_prot.write_field_end()?;
      },
      TTypeQualifierValue::StringValue(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("stringValue", TType::String, 2))?;
        o_prot.write_string(f)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTypeQualifiers
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTypeQualifiers {
  pub qualifiers: BTreeMap<String, TTypeQualifierValue>,
}

impl TTypeQualifiers {
  pub fn new(qualifiers: BTreeMap<String, TTypeQualifierValue>) -> TTypeQualifiers {
    TTypeQualifiers {
      qualifiers,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeQualifiers> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, TTypeQualifierValue>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, TTypeQualifierValue> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_0 = i_prot.read_string()?;
            let map_val_1 = TTypeQualifierValue::read_from_in_protocol(i_prot)?;
            val.insert(map_key_0, map_val_1);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTypeQualifiers.qualifiers", &f_1)?;
    let ret = TTypeQualifiers {
      qualifiers: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTypeQualifiers");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("qualifiers", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, self.qualifiers.len() as i32))?;
    for (k, v) in &self.qualifiers {
      o_prot.write_string(k)?;
      v.write_to_out_protocol(o_prot)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPrimitiveTypeEntry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPrimitiveTypeEntry {
  pub type_: TTypeId,
  pub type_qualifiers: Option<TTypeQualifiers>,
}

impl TPrimitiveTypeEntry {
  pub fn new<F2>(type_: TTypeId, type_qualifiers: F2) -> TPrimitiveTypeEntry where F2: Into<Option<TTypeQualifiers>> {
    TPrimitiveTypeEntry {
      type_,
      type_qualifiers: type_qualifiers.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPrimitiveTypeEntry> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TTypeId> = None;
    let mut f_2: Option<TTypeQualifiers> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TTypeId::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TTypeQualifiers::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPrimitiveTypeEntry.type_", &f_1)?;
    let ret = TPrimitiveTypeEntry {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      type_qualifiers: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPrimitiveTypeEntry");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.type_qualifiers {
      o_prot.write_field_begin(&TFieldIdentifier::new("typeQualifiers", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TArrayTypeEntry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TArrayTypeEntry {
  pub object_type_ptr: TTypeEntryPtr,
}

impl TArrayTypeEntry {
  pub fn new(object_type_ptr: TTypeEntryPtr) -> TArrayTypeEntry {
    TArrayTypeEntry {
      object_type_ptr,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TArrayTypeEntry> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TTypeEntryPtr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TArrayTypeEntry.object_type_ptr", &f_1)?;
    let ret = TArrayTypeEntry {
      object_type_ptr: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TArrayTypeEntry");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objectTypePtr", TType::I32, 1))?;
    o_prot.write_i32(self.object_type_ptr)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMapTypeEntry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMapTypeEntry {
  pub key_type_ptr: TTypeEntryPtr,
  pub value_type_ptr: TTypeEntryPtr,
}

impl TMapTypeEntry {
  pub fn new(key_type_ptr: TTypeEntryPtr, value_type_ptr: TTypeEntryPtr) -> TMapTypeEntry {
    TMapTypeEntry {
      key_type_ptr,
      value_type_ptr,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMapTypeEntry> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TTypeEntryPtr> = None;
    let mut f_2: Option<TTypeEntryPtr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMapTypeEntry.key_type_ptr", &f_1)?;
    verify_required_field_exists("TMapTypeEntry.value_type_ptr", &f_2)?;
    let ret = TMapTypeEntry {
      key_type_ptr: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value_type_ptr: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMapTypeEntry");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("keyTypePtr", TType::I32, 1))?;
    o_prot.write_i32(self.key_type_ptr)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valueTypePtr", TType::I32, 2))?;
    o_prot.write_i32(self.value_type_ptr)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TStructTypeEntry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStructTypeEntry {
  pub name_to_type_ptr: BTreeMap<String, TTypeEntryPtr>,
}

impl TStructTypeEntry {
  pub fn new(name_to_type_ptr: BTreeMap<String, TTypeEntryPtr>) -> TStructTypeEntry {
    TStructTypeEntry {
      name_to_type_ptr,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStructTypeEntry> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, TTypeEntryPtr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, TTypeEntryPtr> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_2 = i_prot.read_string()?;
            let map_val_3 = i_prot.read_i32()?;
            val.insert(map_key_2, map_val_3);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TStructTypeEntry.name_to_type_ptr", &f_1)?;
    let ret = TStructTypeEntry {
      name_to_type_ptr: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStructTypeEntry");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nameToTypePtr", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, self.name_to_type_ptr.len() as i32))?;
    for (k, v) in &self.name_to_type_ptr {
      o_prot.write_string(k)?;
      o_prot.write_i32(*v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TUnionTypeEntry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUnionTypeEntry {
  pub name_to_type_ptr: BTreeMap<String, TTypeEntryPtr>,
}

impl TUnionTypeEntry {
  pub fn new(name_to_type_ptr: BTreeMap<String, TTypeEntryPtr>) -> TUnionTypeEntry {
    TUnionTypeEntry {
      name_to_type_ptr,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUnionTypeEntry> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, TTypeEntryPtr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, TTypeEntryPtr> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_4 = i_prot.read_string()?;
            let map_val_5 = i_prot.read_i32()?;
            val.insert(map_key_4, map_val_5);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TUnionTypeEntry.name_to_type_ptr", &f_1)?;
    let ret = TUnionTypeEntry {
      name_to_type_ptr: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TUnionTypeEntry");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nameToTypePtr", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, self.name_to_type_ptr.len() as i32))?;
    for (k, v) in &self.name_to_type_ptr {
      o_prot.write_string(k)?;
      o_prot.write_i32(*v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TUserDefinedTypeEntry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUserDefinedTypeEntry {
  pub type_class_name: String,
}

impl TUserDefinedTypeEntry {
  pub fn new(type_class_name: String) -> TUserDefinedTypeEntry {
    TUserDefinedTypeEntry {
      type_class_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUserDefinedTypeEntry> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TUserDefinedTypeEntry.type_class_name", &f_1)?;
    let ret = TUserDefinedTypeEntry {
      type_class_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TUserDefinedTypeEntry");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("typeClassName", TType::String, 1))?;
    o_prot.write_string(&self.type_class_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTypeEntry
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TTypeEntry {
  PrimitiveEntry(TPrimitiveTypeEntry),
  ArrayEntry(TArrayTypeEntry),
  MapEntry(TMapTypeEntry),
  StructEntry(TStructTypeEntry),
  UnionEntry(TUnionTypeEntry),
  UserDefinedTypeEntry(TUserDefinedTypeEntry),
}

impl TTypeEntry {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeEntry> {
    let mut ret: Option<TTypeEntry> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPrimitiveTypeEntry::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TTypeEntry::PrimitiveEntry(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = TArrayTypeEntry::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TTypeEntry::ArrayEntry(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TMapTypeEntry::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TTypeEntry::MapEntry(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = TStructTypeEntry::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TTypeEntry::StructEntry(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = TUnionTypeEntry::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TTypeEntry::UnionEntry(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = TUserDefinedTypeEntry::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TTypeEntry::UserDefinedTypeEntry(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TTypeEntry"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TTypeEntry"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTypeEntry");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TTypeEntry::PrimitiveEntry(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("primitiveEntry", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TTypeEntry::ArrayEntry(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("arrayEntry", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TTypeEntry::MapEntry(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("mapEntry", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TTypeEntry::StructEntry(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("structEntry", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TTypeEntry::UnionEntry(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("unionEntry", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TTypeEntry::UserDefinedTypeEntry(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("userDefinedTypeEntry", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTypeDesc
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTypeDesc {
  pub types: Vec<TTypeEntry>,
}

impl TTypeDesc {
  pub fn new(types: Vec<TTypeEntry>) -> TTypeDesc {
    TTypeDesc {
      types,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TTypeEntry>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTypeEntry> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = TTypeEntry::read_from_in_protocol(i_prot)?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTypeDesc.types", &f_1)?;
    let ret = TTypeDesc {
      types: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTypeDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("types", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.types.len() as i32))?;
    for e in &self.types {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TColumnDesc
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnDesc {
  pub column_name: String,
  pub type_desc: TTypeDesc,
  pub position: i32,
  pub comment: Option<String>,
}

impl TColumnDesc {
  pub fn new<F4>(column_name: String, type_desc: TTypeDesc, position: i32, comment: F4) -> TColumnDesc where F4: Into<Option<String>> {
    TColumnDesc {
      column_name,
      type_desc,
      position,
      comment: comment.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<TTypeDesc> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TTypeDesc::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TColumnDesc.column_name", &f_1)?;
    verify_required_field_exists("TColumnDesc.type_desc", &f_2)?;
    verify_required_field_exists("TColumnDesc.position", &f_3)?;
    let ret = TColumnDesc {
      column_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      type_desc: f_2.expect("auto-generated code should have checked for presence of required fields"),
      position: f_3.expect("auto-generated code should have checked for presence of required fields"),
      comment: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("columnName", TType::String, 1))?;
    o_prot.write_string(&self.column_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("typeDesc", TType::Struct, 2))?;
    self.type_desc.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("position", TType::I32, 3))?;
    o_prot.write_i32(self.position)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.comment {
      o_prot.write_field_begin(&TFieldIdentifier::new("comment", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTableSchema
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableSchema {
  pub columns: Vec<TColumnDesc>,
}

impl TTableSchema {
  pub fn new(columns: Vec<TColumnDesc>) -> TTableSchema {
    TTableSchema {
      columns,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableSchema> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TColumnDesc>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = TColumnDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTableSchema.columns", &f_1)?;
    let ret = TTableSchema {
      columns: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableSchema");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.columns.len() as i32))?;
    for e in &self.columns {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBoolValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBoolValue {
  pub value: Option<bool>,
}

impl TBoolValue {
  pub fn new<F1>(value: F1) -> TBoolValue where F1: Into<Option<bool>> {
    TBoolValue {
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBoolValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TBoolValue {
      value: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBoolValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TBoolValue {
  fn default() -> Self {
    TBoolValue{
      value: Some(false),
    }
  }
}

//
// TByteValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TByteValue {
  pub value: Option<i8>,
}

impl TByteValue {
  pub fn new<F1>(value: F1) -> TByteValue where F1: Into<Option<i8>> {
    TByteValue {
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TByteValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TByteValue {
      value: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TByteValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I08, 1))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TByteValue {
  fn default() -> Self {
    TByteValue{
      value: Some(0),
    }
  }
}

//
// TI16Value
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TI16Value {
  pub value: Option<i16>,
}

impl TI16Value {
  pub fn new<F1>(value: F1) -> TI16Value where F1: Into<Option<i16>> {
    TI16Value {
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TI16Value> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i16()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TI16Value {
      value: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TI16Value");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I16, 1))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TI16Value {
  fn default() -> Self {
    TI16Value{
      value: Some(0),
    }
  }
}

//
// TI32Value
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TI32Value {
  pub value: Option<i32>,
}

impl TI32Value {
  pub fn new<F1>(value: F1) -> TI32Value where F1: Into<Option<i32>> {
    TI32Value {
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TI32Value> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TI32Value {
      value: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TI32Value");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TI32Value {
  fn default() -> Self {
    TI32Value{
      value: Some(0),
    }
  }
}

//
// TI64Value
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TI64Value {
  pub value: Option<i64>,
}

impl TI64Value {
  pub fn new<F1>(value: F1) -> TI64Value where F1: Into<Option<i64>> {
    TI64Value {
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TI64Value> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TI64Value {
      value: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TI64Value");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TI64Value {
  fn default() -> Self {
    TI64Value{
      value: Some(0),
    }
  }
}

//
// TDoubleValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDoubleValue {
  pub value: Option<OrderedFloat<f64>>,
}

impl TDoubleValue {
  pub fn new<F1>(value: F1) -> TDoubleValue where F1: Into<Option<OrderedFloat<f64>>> {
    TDoubleValue {
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDoubleValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDoubleValue {
      value: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDoubleValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDoubleValue {
  fn default() -> Self {
    TDoubleValue{
      value: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// TStringValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringValue {
  pub value: Option<String>,
}

impl TStringValue {
  pub fn new<F1>(value: F1) -> TStringValue where F1: Into<Option<String>> {
    TStringValue {
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStringValue {
      value: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStringValue {
  fn default() -> Self {
    TStringValue{
      value: Some("".to_owned()),
    }
  }
}

//
// TColumnValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TColumnValue {
  BoolVal(TBoolValue),
  ByteVal(TByteValue),
  I16Val(TI16Value),
  I32Val(TI32Value),
  I64Val(TI64Value),
  DoubleVal(TDoubleValue),
  StringVal(TStringValue),
}

impl TColumnValue {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnValue> {
    let mut ret: Option<TColumnValue> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TBoolValue::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumnValue::BoolVal(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = TByteValue::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumnValue::ByteVal(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TI16Value::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumnValue::I16Val(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = TI32Value::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumnValue::I32Val(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = TI64Value::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumnValue::I64Val(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = TDoubleValue::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumnValue::DoubleVal(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = TStringValue::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumnValue::StringVal(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TColumnValue"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TColumnValue"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnValue");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TColumnValue::BoolVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("boolVal", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumnValue::ByteVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("byteVal", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumnValue::I16Val(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("i16Val", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumnValue::I32Val(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("i32Val", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumnValue::I64Val(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("i64Val", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumnValue::DoubleVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("doubleVal", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumnValue::StringVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("stringVal", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRow {
  pub col_vals: Vec<TColumnValue>,
}

impl TRow {
  pub fn new(col_vals: Vec<TColumnValue>) -> TRow {
    TRow {
      col_vals,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TColumnValue>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = TColumnValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRow.col_vals", &f_1)?;
    let ret = TRow {
      col_vals: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRow");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("colVals", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.col_vals.len() as i32))?;
    for e in &self.col_vals {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBoolColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBoolColumn {
  pub values: Vec<bool>,
  pub nulls: Vec<u8>,
}

impl TBoolColumn {
  pub fn new(values: Vec<bool>, nulls: Vec<u8>) -> TBoolColumn {
    TBoolColumn {
      values,
      nulls,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBoolColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<bool>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = i_prot.read_bool()?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBoolColumn.values", &f_1)?;
    verify_required_field_exists("TBoolColumn.nulls", &f_2)?;
    let ret = TBoolColumn {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBoolColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_bool(*e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::String, 2))?;
    o_prot.write_bytes(&self.nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TByteColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TByteColumn {
  pub values: Vec<i8>,
  pub nulls: Vec<u8>,
}

impl TByteColumn {
  pub fn new(values: Vec<i8>, nulls: Vec<u8>) -> TByteColumn {
    TByteColumn {
      values,
      nulls,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TByteColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i8> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = i_prot.read_i8()?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TByteColumn.values", &f_1)?;
    verify_required_field_exists("TByteColumn.nulls", &f_2)?;
    let ret = TByteColumn {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TByteColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I08, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_i8(*e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::String, 2))?;
    o_prot.write_bytes(&self.nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TI16Column
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TI16Column {
  pub values: Vec<i16>,
  pub nulls: Vec<u8>,
}

impl TI16Column {
  pub fn new(values: Vec<i16>, nulls: Vec<u8>) -> TI16Column {
    TI16Column {
      values,
      nulls,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TI16Column> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i16>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i16> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = i_prot.read_i16()?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TI16Column.values", &f_1)?;
    verify_required_field_exists("TI16Column.nulls", &f_2)?;
    let ret = TI16Column {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TI16Column");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I16, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_i16(*e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::String, 2))?;
    o_prot.write_bytes(&self.nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TI32Column
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TI32Column {
  pub values: Vec<i32>,
  pub nulls: Vec<u8>,
}

impl TI32Column {
  pub fn new(values: Vec<i32>, nulls: Vec<u8>) -> TI32Column {
    TI32Column {
      values,
      nulls,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TI32Column> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i32>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_i32()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TI32Column.values", &f_1)?;
    verify_required_field_exists("TI32Column.nulls", &f_2)?;
    let ret = TI32Column {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TI32Column");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_i32(*e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::String, 2))?;
    o_prot.write_bytes(&self.nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TI64Column
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TI64Column {
  pub values: Vec<i64>,
  pub nulls: Vec<u8>,
}

impl TI64Column {
  pub fn new(values: Vec<i64>, nulls: Vec<u8>) -> TI64Column {
    TI64Column {
      values,
      nulls,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TI64Column> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = i_prot.read_i64()?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TI64Column.values", &f_1)?;
    verify_required_field_exists("TI64Column.nulls", &f_2)?;
    let ret = TI64Column {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TI64Column");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_i64(*e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::String, 2))?;
    o_prot.write_bytes(&self.nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDoubleColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDoubleColumn {
  pub values: Vec<OrderedFloat<f64>>,
  pub nulls: Vec<u8>,
}

impl TDoubleColumn {
  pub fn new(values: Vec<OrderedFloat<f64>>, nulls: Vec<u8>) -> TDoubleColumn {
    TDoubleColumn {
      values,
      nulls,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDoubleColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<OrderedFloat<f64>>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<OrderedFloat<f64>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = OrderedFloat::from(i_prot.read_double()?);
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDoubleColumn.values", &f_1)?;
    verify_required_field_exists("TDoubleColumn.nulls", &f_2)?;
    let ret = TDoubleColumn {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDoubleColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_double((*e).into())?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::String, 2))?;
    o_prot.write_bytes(&self.nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TStringColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringColumn {
  pub values: Vec<String>,
  pub nulls: Vec<u8>,
}

impl TStringColumn {
  pub fn new(values: Vec<String>, nulls: Vec<u8>) -> TStringColumn {
    TStringColumn {
      values,
      nulls,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = i_prot.read_string()?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TStringColumn.values", &f_1)?;
    verify_required_field_exists("TStringColumn.nulls", &f_2)?;
    let ret = TStringColumn {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::String, 2))?;
    o_prot.write_bytes(&self.nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBinaryColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBinaryColumn {
  pub values: Vec<Vec<u8>>,
  pub nulls: Vec<u8>,
}

impl TBinaryColumn {
  pub fn new(values: Vec<Vec<u8>>, nulls: Vec<u8>) -> TBinaryColumn {
    TBinaryColumn {
      values,
      nulls,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBinaryColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Vec<u8>>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_bytes()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBinaryColumn.values", &f_1)?;
    verify_required_field_exists("TBinaryColumn.nulls", &f_2)?;
    let ret = TBinaryColumn {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nulls: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBinaryColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_bytes(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::String, 2))?;
    o_prot.write_bytes(&self.nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TColumn {
  BoolVal(TBoolColumn),
  ByteVal(TByteColumn),
  I16Val(TI16Column),
  I32Val(TI32Column),
  I64Val(TI64Column),
  DoubleVal(TDoubleColumn),
  StringVal(TStringColumn),
  BinaryVal(TBinaryColumn),
}

impl TColumn {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumn> {
    let mut ret: Option<TColumn> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TBoolColumn::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumn::BoolVal(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = TByteColumn::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumn::ByteVal(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TI16Column::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumn::I16Val(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = TI32Column::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumn::I32Val(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = TI64Column::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumn::I64Val(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = TDoubleColumn::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumn::DoubleVal(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = TStringColumn::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumn::StringVal(val));
          }
          received_field_count += 1;
        },
        8 => {
          let val = TBinaryColumn::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TColumn::BinaryVal(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TColumn"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TColumn"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TColumn::BoolVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("boolVal", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumn::ByteVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("byteVal", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumn::I16Val(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("i16Val", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumn::I32Val(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("i32Val", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumn::I64Val(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("i64Val", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumn::DoubleVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("doubleVal", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumn::StringVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("stringVal", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TColumn::BinaryVal(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("binaryVal", TType::Struct, 8))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRowSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRowSet {
  pub start_row_offset: i64,
  pub rows: Vec<TRow>,
  pub columns: Option<Vec<TColumn>>,
  pub binary_columns: Option<Vec<u8>>,
  pub column_count: Option<i32>,
}

impl TRowSet {
  pub fn new<F3, F4, F5>(start_row_offset: i64, rows: Vec<TRow>, columns: F3, binary_columns: F4, column_count: F5) -> TRowSet where F3: Into<Option<Vec<TColumn>>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<i32>> {
    TRowSet {
      start_row_offset,
      rows,
      columns: columns.into(),
      binary_columns: binary_columns.into(),
      column_count: column_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRowSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<TRow>> = None;
    let mut f_3: Option<Vec<TColumn>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = TRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRowSet.start_row_offset", &f_1)?;
    verify_required_field_exists("TRowSet.rows", &f_2)?;
    let ret = TRowSet {
      start_row_offset: f_1.expect("auto-generated code should have checked for presence of required fields"),
      rows: f_2.expect("auto-generated code should have checked for presence of required fields"),
      columns: f_3,
      binary_columns: f_4,
      column_count: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRowSet");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startRowOffset", TType::I64, 1))?;
    o_prot.write_i64(self.start_row_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.rows.len() as i32))?;
    for e in &self.rows {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.binary_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("binaryColumns", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.column_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnCount", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStatus {
  pub status_code: TStatusCode,
  pub info_messages: Option<Vec<String>>,
  pub sql_state: Option<String>,
  pub error_code: Option<i32>,
  pub error_message: Option<String>,
}

impl TStatus {
  pub fn new<F2, F3, F4, F5>(status_code: TStatusCode, info_messages: F2, sql_state: F3, error_code: F4, error_message: F5) -> TStatus where F2: Into<Option<Vec<String>>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<String>> {
    TStatus {
      status_code,
      info_messages: info_messages.into(),
      sql_state: sql_state.into(),
      error_code: error_code.into(),
      error_message: error_message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatusCode> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatusCode::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TStatus.status_code", &f_1)?;
    let ret = TStatus {
      status_code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      info_messages: f_2,
      sql_state: f_3,
      error_code: f_4,
      error_message: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statusCode", TType::I32, 1))?;
    self.status_code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.info_messages {
      o_prot.write_field_begin(&TFieldIdentifier::new("infoMessages", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sql_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("sqlState", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.error_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("errorCode", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.error_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("errorMessage", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// THandleIdentifier
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THandleIdentifier {
  pub guid: Vec<u8>,
  pub secret: Vec<u8>,
}

impl THandleIdentifier {
  pub fn new(guid: Vec<u8>, secret: Vec<u8>) -> THandleIdentifier {
    THandleIdentifier {
      guid,
      secret,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THandleIdentifier> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("THandleIdentifier.guid", &f_1)?;
    verify_required_field_exists("THandleIdentifier.secret", &f_2)?;
    let ret = THandleIdentifier {
      guid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      secret: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THandleIdentifier");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
    o_prot.write_bytes(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secret", TType::String, 2))?;
    o_prot.write_bytes(&self.secret)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSessionHandle
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSessionHandle {
  pub session_id: THandleIdentifier,
}

impl TSessionHandle {
  pub fn new(session_id: THandleIdentifier) -> TSessionHandle {
    TSessionHandle {
      session_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSessionHandle> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<THandleIdentifier> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = THandleIdentifier::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSessionHandle.session_id", &f_1)?;
    let ret = TSessionHandle {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSessionHandle");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::Struct, 1))?;
    self.session_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOperationHandle
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOperationHandle {
  pub operation_id: THandleIdentifier,
  pub operation_type: TOperationType,
  pub has_result_set: bool,
  pub modified_row_count: Option<OrderedFloat<f64>>,
}

impl TOperationHandle {
  pub fn new<F4>(operation_id: THandleIdentifier, operation_type: TOperationType, has_result_set: bool, modified_row_count: F4) -> TOperationHandle where F4: Into<Option<OrderedFloat<f64>>> {
    TOperationHandle {
      operation_id,
      operation_type,
      has_result_set,
      modified_row_count: modified_row_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOperationHandle> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<THandleIdentifier> = None;
    let mut f_2: Option<TOperationType> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = THandleIdentifier::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOperationHandle.operation_id", &f_1)?;
    verify_required_field_exists("TOperationHandle.operation_type", &f_2)?;
    verify_required_field_exists("TOperationHandle.has_result_set", &f_3)?;
    let ret = TOperationHandle {
      operation_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      has_result_set: f_3.expect("auto-generated code should have checked for presence of required fields"),
      modified_row_count: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOperationHandle");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("operationId", TType::Struct, 1))?;
    self.operation_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("operationType", TType::I32, 2))?;
    self.operation_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hasResultSet", TType::Bool, 3))?;
    o_prot.write_bool(self.has_result_set)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.modified_row_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("modifiedRowCount", TType::Double, 4))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOpenSessionReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOpenSessionReq {
  pub client_protocol: TProtocolVersion,
  pub username: Option<String>,
  pub password: Option<String>,
  pub configuration: Option<BTreeMap<String, String>>,
}

impl TOpenSessionReq {
  pub fn new<F2, F3, F4>(client_protocol: TProtocolVersion, username: F2, password: F3, configuration: F4) -> TOpenSessionReq where F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<BTreeMap<String, String>>> {
    TOpenSessionReq {
      client_protocol,
      username: username.into(),
      password: password.into(),
      configuration: configuration.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOpenSessionReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TProtocolVersion> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TProtocolVersion::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_20 = i_prot.read_string()?;
            let map_val_21 = i_prot.read_string()?;
            val.insert(map_key_20, map_val_21);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOpenSessionReq.client_protocol", &f_1)?;
    let ret = TOpenSessionReq {
      client_protocol: f_1.expect("auto-generated code should have checked for presence of required fields"),
      username: f_2,
      password: f_3,
      configuration: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOpenSessionReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("client_protocol", TType::I32, 1))?;
    self.client_protocol.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.password {
      o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOpenSessionResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOpenSessionResp {
  pub status: TStatus,
  pub server_protocol_version: TProtocolVersion,
  pub session_handle: Option<TSessionHandle>,
  pub configuration: Option<BTreeMap<String, String>>,
}

impl TOpenSessionResp {
  pub fn new<F3, F4>(status: TStatus, server_protocol_version: TProtocolVersion, session_handle: F3, configuration: F4) -> TOpenSessionResp where F3: Into<Option<TSessionHandle>>, F4: Into<Option<BTreeMap<String, String>>> {
    TOpenSessionResp {
      status,
      server_protocol_version,
      session_handle: session_handle.into(),
      configuration: configuration.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOpenSessionResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TProtocolVersion> = None;
    let mut f_3: Option<TSessionHandle> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TProtocolVersion::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_22 = i_prot.read_string()?;
            let map_val_23 = i_prot.read_string()?;
            val.insert(map_key_22, map_val_23);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOpenSessionResp.status", &f_1)?;
    verify_required_field_exists("TOpenSessionResp.server_protocol_version", &f_2)?;
    let ret = TOpenSessionResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      server_protocol_version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      session_handle: f_3,
      configuration: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOpenSessionResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serverProtocolVersion", TType::I32, 2))?;
    self.server_protocol_version.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.session_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSetClientInfoReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetClientInfoReq {
  pub session_handle: TSessionHandle,
  pub configuration: Option<BTreeMap<String, String>>,
}

impl TSetClientInfoReq {
  pub fn new<F2>(session_handle: TSessionHandle, configuration: F2) -> TSetClientInfoReq where F2: Into<Option<BTreeMap<String, String>>> {
    TSetClientInfoReq {
      session_handle,
      configuration: configuration.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetClientInfoReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_24 = i_prot.read_string()?;
            let map_val_25 = i_prot.read_string()?;
            val.insert(map_key_24, map_val_25);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetClientInfoReq.session_handle", &f_1)?;
    let ret = TSetClientInfoReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      configuration: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetClientInfoReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSetClientInfoResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetClientInfoResp {
  pub status: TStatus,
}

impl TSetClientInfoResp {
  pub fn new(status: TStatus) -> TSetClientInfoResp {
    TSetClientInfoResp {
      status,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetClientInfoResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetClientInfoResp.status", &f_1)?;
    let ret = TSetClientInfoResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetClientInfoResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCloseSessionReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCloseSessionReq {
  pub session_handle: TSessionHandle,
}

impl TCloseSessionReq {
  pub fn new(session_handle: TSessionHandle) -> TCloseSessionReq {
    TCloseSessionReq {
      session_handle,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCloseSessionReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCloseSessionReq.session_handle", &f_1)?;
    let ret = TCloseSessionReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCloseSessionReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCloseSessionResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCloseSessionResp {
  pub status: TStatus,
}

impl TCloseSessionResp {
  pub fn new(status: TStatus) -> TCloseSessionResp {
    TCloseSessionResp {
      status,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCloseSessionResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCloseSessionResp.status", &f_1)?;
    let ret = TCloseSessionResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCloseSessionResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetInfoValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TGetInfoValue {
  StringValue(String),
  SmallIntValue(i16),
  IntegerBitmask(i32),
  IntegerFlag(i32),
  BinaryValue(i32),
  LenValue(i64),
}

impl TGetInfoValue {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetInfoValue> {
    let mut ret: Option<TGetInfoValue> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          if ret.is_none() {
            ret = Some(TGetInfoValue::StringValue(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = i_prot.read_i16()?;
          if ret.is_none() {
            ret = Some(TGetInfoValue::SmallIntValue(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = i_prot.read_i32()?;
          if ret.is_none() {
            ret = Some(TGetInfoValue::IntegerBitmask(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = i_prot.read_i32()?;
          if ret.is_none() {
            ret = Some(TGetInfoValue::IntegerFlag(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = i_prot.read_i32()?;
          if ret.is_none() {
            ret = Some(TGetInfoValue::BinaryValue(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = i_prot.read_i64()?;
          if ret.is_none() {
            ret = Some(TGetInfoValue::LenValue(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TGetInfoValue"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TGetInfoValue"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetInfoValue");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TGetInfoValue::StringValue(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("stringValue", TType::String, 1))?;
        o_prot.write_string(f)?;
        o_prot.write_field_end()?;
      },
      TGetInfoValue::SmallIntValue(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("smallIntValue", TType::I16, 2))?;
        o_prot.write_i16(f)?;
        o_prot.write_field_end()?;
      },
      TGetInfoValue::IntegerBitmask(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("integerBitmask", TType::I32, 3))?;
        o_prot.write_i32(f)?;
        o_prot.write_field_end()?;
      },
      TGetInfoValue::IntegerFlag(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("integerFlag", TType::I32, 4))?;
        o_prot.write_i32(f)?;
        o_prot.write_field_end()?;
      },
      TGetInfoValue::BinaryValue(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("binaryValue", TType::I32, 5))?;
        o_prot.write_i32(f)?;
        o_prot.write_field_end()?;
      },
      TGetInfoValue::LenValue(f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("lenValue", TType::I64, 6))?;
        o_prot.write_i64(f)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetInfoReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetInfoReq {
  pub session_handle: TSessionHandle,
  pub info_type: TGetInfoType,
}

impl TGetInfoReq {
  pub fn new(session_handle: TSessionHandle, info_type: TGetInfoType) -> TGetInfoReq {
    TGetInfoReq {
      session_handle,
      info_type,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetInfoReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<TGetInfoType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TGetInfoType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetInfoReq.session_handle", &f_1)?;
    verify_required_field_exists("TGetInfoReq.info_type", &f_2)?;
    let ret = TGetInfoReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      info_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetInfoReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("infoType", TType::I32, 2))?;
    self.info_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetInfoResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetInfoResp {
  pub status: TStatus,
  pub info_value: TGetInfoValue,
}

impl TGetInfoResp {
  pub fn new(status: TStatus, info_value: TGetInfoValue) -> TGetInfoResp {
    TGetInfoResp {
      status,
      info_value,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetInfoResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TGetInfoValue> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TGetInfoValue::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetInfoResp.status", &f_1)?;
    verify_required_field_exists("TGetInfoResp.info_value", &f_2)?;
    let ret = TGetInfoResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      info_value: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetInfoResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("infoValue", TType::Struct, 2))?;
    self.info_value.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TExecuteStatementReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExecuteStatementReq {
  pub session_handle: TSessionHandle,
  pub statement: String,
  pub conf_overlay: Option<BTreeMap<String, String>>,
  pub run_async: Option<bool>,
  pub query_timeout: Option<i64>,
}

impl TExecuteStatementReq {
  pub fn new<F3, F4, F5>(session_handle: TSessionHandle, statement: String, conf_overlay: F3, run_async: F4, query_timeout: F5) -> TExecuteStatementReq where F3: Into<Option<BTreeMap<String, String>>>, F4: Into<Option<bool>>, F5: Into<Option<i64>> {
    TExecuteStatementReq {
      session_handle,
      statement,
      conf_overlay: conf_overlay.into(),
      run_async: run_async.into(),
      query_timeout: query_timeout.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExecuteStatementReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_26 = i_prot.read_string()?;
            let map_val_27 = i_prot.read_string()?;
            val.insert(map_key_26, map_val_27);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TExecuteStatementReq.session_handle", &f_1)?;
    verify_required_field_exists("TExecuteStatementReq.statement", &f_2)?;
    let ret = TExecuteStatementReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      statement: f_2.expect("auto-generated code should have checked for presence of required fields"),
      conf_overlay: f_3,
      run_async: f_4,
      query_timeout: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TExecuteStatementReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statement", TType::String, 2))?;
    o_prot.write_string(&self.statement)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.conf_overlay {
      o_prot.write_field_begin(&TFieldIdentifier::new("confOverlay", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.run_async {
      o_prot.write_field_begin(&TFieldIdentifier::new("runAsync", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.query_timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryTimeout", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TExecuteStatementResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExecuteStatementResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TExecuteStatementResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TExecuteStatementResp where F2: Into<Option<TOperationHandle>> {
    TExecuteStatementResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExecuteStatementResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TExecuteStatementResp.status", &f_1)?;
    let ret = TExecuteStatementResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TExecuteStatementResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetTypeInfoReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetTypeInfoReq {
  pub session_handle: TSessionHandle,
}

impl TGetTypeInfoReq {
  pub fn new(session_handle: TSessionHandle) -> TGetTypeInfoReq {
    TGetTypeInfoReq {
      session_handle,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetTypeInfoReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetTypeInfoReq.session_handle", &f_1)?;
    let ret = TGetTypeInfoReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetTypeInfoReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetTypeInfoResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetTypeInfoResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetTypeInfoResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetTypeInfoResp where F2: Into<Option<TOperationHandle>> {
    TGetTypeInfoResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetTypeInfoResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetTypeInfoResp.status", &f_1)?;
    let ret = TGetTypeInfoResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetTypeInfoResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetCatalogsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetCatalogsReq {
  pub session_handle: TSessionHandle,
}

impl TGetCatalogsReq {
  pub fn new(session_handle: TSessionHandle) -> TGetCatalogsReq {
    TGetCatalogsReq {
      session_handle,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetCatalogsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetCatalogsReq.session_handle", &f_1)?;
    let ret = TGetCatalogsReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetCatalogsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetCatalogsResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetCatalogsResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetCatalogsResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetCatalogsResp where F2: Into<Option<TOperationHandle>> {
    TGetCatalogsResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetCatalogsResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetCatalogsResp.status", &f_1)?;
    let ret = TGetCatalogsResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetCatalogsResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetSchemasReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetSchemasReq {
  pub session_handle: TSessionHandle,
  pub catalog_name: Option<TIdentifier>,
  pub schema_name: Option<TPatternOrIdentifier>,
}

impl TGetSchemasReq {
  pub fn new<F2, F3>(session_handle: TSessionHandle, catalog_name: F2, schema_name: F3) -> TGetSchemasReq where F2: Into<Option<TIdentifier>>, F3: Into<Option<TPatternOrIdentifier>> {
    TGetSchemasReq {
      session_handle,
      catalog_name: catalog_name.into(),
      schema_name: schema_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetSchemasReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<TIdentifier> = None;
    let mut f_3: Option<TPatternOrIdentifier> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetSchemasReq.session_handle", &f_1)?;
    let ret = TGetSchemasReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      catalog_name: f_2,
      schema_name: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetSchemasReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalogName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetSchemasResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetSchemasResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetSchemasResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetSchemasResp where F2: Into<Option<TOperationHandle>> {
    TGetSchemasResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetSchemasResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetSchemasResp.status", &f_1)?;
    let ret = TGetSchemasResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetSchemasResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetTablesReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetTablesReq {
  pub session_handle: TSessionHandle,
  pub catalog_name: Option<TPatternOrIdentifier>,
  pub schema_name: Option<TPatternOrIdentifier>,
  pub table_name: Option<TPatternOrIdentifier>,
  pub table_types: Option<Vec<String>>,
}

impl TGetTablesReq {
  pub fn new<F2, F3, F4, F5>(session_handle: TSessionHandle, catalog_name: F2, schema_name: F3, table_name: F4, table_types: F5) -> TGetTablesReq where F2: Into<Option<TPatternOrIdentifier>>, F3: Into<Option<TPatternOrIdentifier>>, F4: Into<Option<TPatternOrIdentifier>>, F5: Into<Option<Vec<String>>> {
    TGetTablesReq {
      session_handle,
      catalog_name: catalog_name.into(),
      schema_name: schema_name.into(),
      table_name: table_name.into(),
      table_types: table_types.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetTablesReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<TPatternOrIdentifier> = None;
    let mut f_3: Option<TPatternOrIdentifier> = None;
    let mut f_4: Option<TPatternOrIdentifier> = None;
    let mut f_5: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = i_prot.read_string()?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetTablesReq.session_handle", &f_1)?;
    let ret = TGetTablesReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      catalog_name: f_2,
      schema_name: f_3,
      table_name: f_4,
      table_types: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetTablesReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalogName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableTypes", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetTablesResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetTablesResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetTablesResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetTablesResp where F2: Into<Option<TOperationHandle>> {
    TGetTablesResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetTablesResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetTablesResp.status", &f_1)?;
    let ret = TGetTablesResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetTablesResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetTableTypesReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetTableTypesReq {
  pub session_handle: TSessionHandle,
}

impl TGetTableTypesReq {
  pub fn new(session_handle: TSessionHandle) -> TGetTableTypesReq {
    TGetTableTypesReq {
      session_handle,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetTableTypesReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetTableTypesReq.session_handle", &f_1)?;
    let ret = TGetTableTypesReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetTableTypesReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetTableTypesResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetTableTypesResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetTableTypesResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetTableTypesResp where F2: Into<Option<TOperationHandle>> {
    TGetTableTypesResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetTableTypesResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetTableTypesResp.status", &f_1)?;
    let ret = TGetTableTypesResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetTableTypesResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetColumnsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetColumnsReq {
  pub session_handle: TSessionHandle,
  pub catalog_name: Option<TIdentifier>,
  pub schema_name: Option<TPatternOrIdentifier>,
  pub table_name: Option<TPatternOrIdentifier>,
  pub column_name: Option<TPatternOrIdentifier>,
}

impl TGetColumnsReq {
  pub fn new<F2, F3, F4, F5>(session_handle: TSessionHandle, catalog_name: F2, schema_name: F3, table_name: F4, column_name: F5) -> TGetColumnsReq where F2: Into<Option<TIdentifier>>, F3: Into<Option<TPatternOrIdentifier>>, F4: Into<Option<TPatternOrIdentifier>>, F5: Into<Option<TPatternOrIdentifier>> {
    TGetColumnsReq {
      session_handle,
      catalog_name: catalog_name.into(),
      schema_name: schema_name.into(),
      table_name: table_name.into(),
      column_name: column_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetColumnsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<TIdentifier> = None;
    let mut f_3: Option<TPatternOrIdentifier> = None;
    let mut f_4: Option<TPatternOrIdentifier> = None;
    let mut f_5: Option<TPatternOrIdentifier> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetColumnsReq.session_handle", &f_1)?;
    let ret = TGetColumnsReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      catalog_name: f_2,
      schema_name: f_3,
      table_name: f_4,
      column_name: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetColumnsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalogName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnName", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetColumnsResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetColumnsResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetColumnsResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetColumnsResp where F2: Into<Option<TOperationHandle>> {
    TGetColumnsResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetColumnsResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetColumnsResp.status", &f_1)?;
    let ret = TGetColumnsResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetColumnsResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetFunctionsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetFunctionsReq {
  pub session_handle: TSessionHandle,
  pub catalog_name: Option<TIdentifier>,
  pub schema_name: Option<TPatternOrIdentifier>,
  pub function_name: TPatternOrIdentifier,
}

impl TGetFunctionsReq {
  pub fn new<F2, F3>(session_handle: TSessionHandle, catalog_name: F2, schema_name: F3, function_name: TPatternOrIdentifier) -> TGetFunctionsReq where F2: Into<Option<TIdentifier>>, F3: Into<Option<TPatternOrIdentifier>> {
    TGetFunctionsReq {
      session_handle,
      catalog_name: catalog_name.into(),
      schema_name: schema_name.into(),
      function_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetFunctionsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<TIdentifier> = None;
    let mut f_3: Option<TPatternOrIdentifier> = None;
    let mut f_4: Option<TPatternOrIdentifier> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetFunctionsReq.session_handle", &f_1)?;
    verify_required_field_exists("TGetFunctionsReq.function_name", &f_4)?;
    let ret = TGetFunctionsReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      catalog_name: f_2,
      schema_name: f_3,
      function_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetFunctionsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalogName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("functionName", TType::String, 4))?;
    o_prot.write_string(&self.function_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetFunctionsResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetFunctionsResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetFunctionsResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetFunctionsResp where F2: Into<Option<TOperationHandle>> {
    TGetFunctionsResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetFunctionsResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetFunctionsResp.status", &f_1)?;
    let ret = TGetFunctionsResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetFunctionsResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetPrimaryKeysReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetPrimaryKeysReq {
  pub session_handle: TSessionHandle,
  pub catalog_name: Option<TIdentifier>,
  pub schema_name: Option<TIdentifier>,
  pub table_name: Option<TIdentifier>,
}

impl TGetPrimaryKeysReq {
  pub fn new<F2, F3, F4>(session_handle: TSessionHandle, catalog_name: F2, schema_name: F3, table_name: F4) -> TGetPrimaryKeysReq where F2: Into<Option<TIdentifier>>, F3: Into<Option<TIdentifier>>, F4: Into<Option<TIdentifier>> {
    TGetPrimaryKeysReq {
      session_handle,
      catalog_name: catalog_name.into(),
      schema_name: schema_name.into(),
      table_name: table_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetPrimaryKeysReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<TIdentifier> = None;
    let mut f_3: Option<TIdentifier> = None;
    let mut f_4: Option<TIdentifier> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetPrimaryKeysReq.session_handle", &f_1)?;
    let ret = TGetPrimaryKeysReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      catalog_name: f_2,
      schema_name: f_3,
      table_name: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetPrimaryKeysReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalogName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetPrimaryKeysResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetPrimaryKeysResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetPrimaryKeysResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetPrimaryKeysResp where F2: Into<Option<TOperationHandle>> {
    TGetPrimaryKeysResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetPrimaryKeysResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetPrimaryKeysResp.status", &f_1)?;
    let ret = TGetPrimaryKeysResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetPrimaryKeysResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetCrossReferenceReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetCrossReferenceReq {
  pub session_handle: TSessionHandle,
  pub parent_catalog_name: Option<TIdentifier>,
  pub parent_schema_name: Option<TIdentifier>,
  pub parent_table_name: Option<TIdentifier>,
  pub foreign_catalog_name: Option<TIdentifier>,
  pub foreign_schema_name: Option<TIdentifier>,
  pub foreign_table_name: Option<TIdentifier>,
}

impl TGetCrossReferenceReq {
  pub fn new<F2, F3, F4, F5, F6, F7>(session_handle: TSessionHandle, parent_catalog_name: F2, parent_schema_name: F3, parent_table_name: F4, foreign_catalog_name: F5, foreign_schema_name: F6, foreign_table_name: F7) -> TGetCrossReferenceReq where F2: Into<Option<TIdentifier>>, F3: Into<Option<TIdentifier>>, F4: Into<Option<TIdentifier>>, F5: Into<Option<TIdentifier>>, F6: Into<Option<TIdentifier>>, F7: Into<Option<TIdentifier>> {
    TGetCrossReferenceReq {
      session_handle,
      parent_catalog_name: parent_catalog_name.into(),
      parent_schema_name: parent_schema_name.into(),
      parent_table_name: parent_table_name.into(),
      foreign_catalog_name: foreign_catalog_name.into(),
      foreign_schema_name: foreign_schema_name.into(),
      foreign_table_name: foreign_table_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetCrossReferenceReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<TIdentifier> = None;
    let mut f_3: Option<TIdentifier> = None;
    let mut f_4: Option<TIdentifier> = None;
    let mut f_5: Option<TIdentifier> = None;
    let mut f_6: Option<TIdentifier> = None;
    let mut f_7: Option<TIdentifier> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetCrossReferenceReq.session_handle", &f_1)?;
    let ret = TGetCrossReferenceReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parent_catalog_name: f_2,
      parent_schema_name: f_3,
      parent_table_name: f_4,
      foreign_catalog_name: f_5,
      foreign_schema_name: f_6,
      foreign_table_name: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetCrossReferenceReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.parent_catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentCatalogName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_schema_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentSchemaName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentTableName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.foreign_catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("foreignCatalogName", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.foreign_schema_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("foreignSchemaName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.foreign_table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("foreignTableName", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetCrossReferenceResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetCrossReferenceResp {
  pub status: TStatus,
  pub operation_handle: Option<TOperationHandle>,
}

impl TGetCrossReferenceResp {
  pub fn new<F2>(status: TStatus, operation_handle: F2) -> TGetCrossReferenceResp where F2: Into<Option<TOperationHandle>> {
    TGetCrossReferenceResp {
      status,
      operation_handle: operation_handle.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetCrossReferenceResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetCrossReferenceResp.status", &f_1)?;
    let ret = TGetCrossReferenceResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_handle: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetCrossReferenceResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetOperationStatusReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetOperationStatusReq {
  pub operation_handle: TOperationHandle,
  pub get_progress_update: Option<bool>,
}

impl TGetOperationStatusReq {
  pub fn new<F2>(operation_handle: TOperationHandle, get_progress_update: F2) -> TGetOperationStatusReq where F2: Into<Option<bool>> {
    TGetOperationStatusReq {
      operation_handle,
      get_progress_update: get_progress_update.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetOperationStatusReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOperationHandle> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetOperationStatusReq.operation_handle", &f_1)?;
    let ret = TGetOperationStatusReq {
      operation_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      get_progress_update: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetOperationStatusReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 1))?;
    self.operation_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.get_progress_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("getProgressUpdate", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetOperationStatusResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetOperationStatusResp {
  pub status: TStatus,
  pub operation_state: Option<TOperationState>,
  pub sql_state: Option<String>,
  pub error_code: Option<i32>,
  pub error_message: Option<String>,
  pub task_status: Option<String>,
  pub operation_started: Option<i64>,
  pub operation_completed: Option<i64>,
  pub has_result_set: Option<bool>,
  pub progress_update_response: Option<Box<TProgressUpdateResp>>,
  pub num_modified_rows: Option<i64>,
}

impl TGetOperationStatusResp {
  pub fn new<F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(status: TStatus, operation_state: F2, sql_state: F3, error_code: F4, error_message: F5, task_status: F6, operation_started: F7, operation_completed: F8, has_result_set: F9, progress_update_response: F10, num_modified_rows: F11) -> TGetOperationStatusResp where F2: Into<Option<TOperationState>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<i64>>, F8: Into<Option<i64>>, F9: Into<Option<bool>>, F10: Into<Option<Box<TProgressUpdateResp>>>, F11: Into<Option<i64>> {
    TGetOperationStatusResp {
      status,
      operation_state: operation_state.into(),
      sql_state: sql_state.into(),
      error_code: error_code.into(),
      error_message: error_message.into(),
      task_status: task_status.into(),
      operation_started: operation_started.into(),
      operation_completed: operation_completed.into(),
      has_result_set: has_result_set.into(),
      progress_update_response: progress_update_response.into(),
      num_modified_rows: num_modified_rows.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetOperationStatusResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TOperationState> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<Box<TProgressUpdateResp>> = None;
    let mut f_11: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOperationState::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = Box::new(TProgressUpdateResp::read_from_in_protocol(i_prot)?);
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetOperationStatusResp.status", &f_1)?;
    let ret = TGetOperationStatusResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      operation_state: f_2,
      sql_state: f_3,
      error_code: f_4,
      error_message: f_5,
      task_status: f_6,
      operation_started: f_7,
      operation_completed: f_8,
      has_result_set: f_9,
      progress_update_response: f_10,
      num_modified_rows: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetOperationStatusResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationState", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sql_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("sqlState", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.error_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("errorCode", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.error_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("errorMessage", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStatus", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.operation_started {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationStarted", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.operation_completed {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationCompleted", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.has_result_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasResultSet", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.progress_update_response {
      o_prot.write_field_begin(&TFieldIdentifier::new("progressUpdateResponse", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_modified_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("numModifiedRows", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCancelOperationReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCancelOperationReq {
  pub operation_handle: TOperationHandle,
}

impl TCancelOperationReq {
  pub fn new(operation_handle: TOperationHandle) -> TCancelOperationReq {
    TCancelOperationReq {
      operation_handle,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCancelOperationReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCancelOperationReq.operation_handle", &f_1)?;
    let ret = TCancelOperationReq {
      operation_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCancelOperationReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 1))?;
    self.operation_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCancelOperationResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCancelOperationResp {
  pub status: TStatus,
}

impl TCancelOperationResp {
  pub fn new(status: TStatus) -> TCancelOperationResp {
    TCancelOperationResp {
      status,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCancelOperationResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCancelOperationResp.status", &f_1)?;
    let ret = TCancelOperationResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCancelOperationResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCloseOperationReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCloseOperationReq {
  pub operation_handle: TOperationHandle,
}

impl TCloseOperationReq {
  pub fn new(operation_handle: TOperationHandle) -> TCloseOperationReq {
    TCloseOperationReq {
      operation_handle,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCloseOperationReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCloseOperationReq.operation_handle", &f_1)?;
    let ret = TCloseOperationReq {
      operation_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCloseOperationReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 1))?;
    self.operation_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCloseOperationResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCloseOperationResp {
  pub status: TStatus,
}

impl TCloseOperationResp {
  pub fn new(status: TStatus) -> TCloseOperationResp {
    TCloseOperationResp {
      status,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCloseOperationResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCloseOperationResp.status", &f_1)?;
    let ret = TCloseOperationResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCloseOperationResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetResultSetMetadataReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetResultSetMetadataReq {
  pub operation_handle: TOperationHandle,
}

impl TGetResultSetMetadataReq {
  pub fn new(operation_handle: TOperationHandle) -> TGetResultSetMetadataReq {
    TGetResultSetMetadataReq {
      operation_handle,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetResultSetMetadataReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetResultSetMetadataReq.operation_handle", &f_1)?;
    let ret = TGetResultSetMetadataReq {
      operation_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetResultSetMetadataReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 1))?;
    self.operation_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetResultSetMetadataResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetResultSetMetadataResp {
  pub status: TStatus,
  pub schema: Option<TTableSchema>,
}

impl TGetResultSetMetadataResp {
  pub fn new<F2>(status: TStatus, schema: F2) -> TGetResultSetMetadataResp where F2: Into<Option<TTableSchema>> {
    TGetResultSetMetadataResp {
      status,
      schema: schema.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetResultSetMetadataResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<TTableSchema> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TTableSchema::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetResultSetMetadataResp.status", &f_1)?;
    let ret = TGetResultSetMetadataResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      schema: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetResultSetMetadataResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.schema {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFetchResultsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFetchResultsReq {
  pub operation_handle: TOperationHandle,
  pub orientation: TFetchOrientation,
  pub max_rows: i64,
  pub fetch_type: Option<i16>,
}

impl TFetchResultsReq {
  pub fn new<F4>(operation_handle: TOperationHandle, orientation: TFetchOrientation, max_rows: i64, fetch_type: F4) -> TFetchResultsReq where F4: Into<Option<i16>> {
    TFetchResultsReq {
      operation_handle,
      orientation,
      max_rows,
      fetch_type: fetch_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFetchResultsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOperationHandle> = None;
    let mut f_2: Option<TFetchOrientation> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TFetchOrientation::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFetchResultsReq.operation_handle", &f_1)?;
    verify_required_field_exists("TFetchResultsReq.orientation", &f_2)?;
    verify_required_field_exists("TFetchResultsReq.max_rows", &f_3)?;
    let ret = TFetchResultsReq {
      operation_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      orientation: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
      fetch_type: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFetchResultsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 1))?;
    self.operation_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("orientation", TType::I32, 2))?;
    self.orientation.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxRows", TType::I64, 3))?;
    o_prot.write_i64(self.max_rows)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.fetch_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchType", TType::I16, 4))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFetchResultsResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFetchResultsResp {
  pub status: TStatus,
  pub has_more_rows: Option<bool>,
  pub results: Option<TRowSet>,
}

impl TFetchResultsResp {
  pub fn new<F2, F3>(status: TStatus, has_more_rows: F2, results: F3) -> TFetchResultsResp where F2: Into<Option<bool>>, F3: Into<Option<TRowSet>> {
    TFetchResultsResp {
      status,
      has_more_rows: has_more_rows.into(),
      results: results.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFetchResultsResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<TRowSet> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFetchResultsResp.status", &f_1)?;
    let ret = TFetchResultsResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      has_more_rows: f_2,
      results: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFetchResultsResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.has_more_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasMoreRows", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.results {
      o_prot.write_field_begin(&TFieldIdentifier::new("results", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetDelegationTokenReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetDelegationTokenReq {
  pub session_handle: TSessionHandle,
  pub owner: String,
  pub renewer: String,
}

impl TGetDelegationTokenReq {
  pub fn new(session_handle: TSessionHandle, owner: String, renewer: String) -> TGetDelegationTokenReq {
    TGetDelegationTokenReq {
      session_handle,
      owner,
      renewer,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetDelegationTokenReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetDelegationTokenReq.session_handle", &f_1)?;
    verify_required_field_exists("TGetDelegationTokenReq.owner", &f_2)?;
    verify_required_field_exists("TGetDelegationTokenReq.renewer", &f_3)?;
    let ret = TGetDelegationTokenReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      owner: f_2.expect("auto-generated code should have checked for presence of required fields"),
      renewer: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetDelegationTokenReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("owner", TType::String, 2))?;
    o_prot.write_string(&self.owner)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("renewer", TType::String, 3))?;
    o_prot.write_string(&self.renewer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetDelegationTokenResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetDelegationTokenResp {
  pub status: TStatus,
  pub delegation_token: Option<String>,
}

impl TGetDelegationTokenResp {
  pub fn new<F2>(status: TStatus, delegation_token: F2) -> TGetDelegationTokenResp where F2: Into<Option<String>> {
    TGetDelegationTokenResp {
      status,
      delegation_token: delegation_token.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetDelegationTokenResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetDelegationTokenResp.status", &f_1)?;
    let ret = TGetDelegationTokenResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      delegation_token: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetDelegationTokenResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.delegation_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("delegationToken", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCancelDelegationTokenReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCancelDelegationTokenReq {
  pub session_handle: TSessionHandle,
  pub delegation_token: String,
}

impl TCancelDelegationTokenReq {
  pub fn new(session_handle: TSessionHandle, delegation_token: String) -> TCancelDelegationTokenReq {
    TCancelDelegationTokenReq {
      session_handle,
      delegation_token,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCancelDelegationTokenReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCancelDelegationTokenReq.session_handle", &f_1)?;
    verify_required_field_exists("TCancelDelegationTokenReq.delegation_token", &f_2)?;
    let ret = TCancelDelegationTokenReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      delegation_token: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCancelDelegationTokenReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("delegationToken", TType::String, 2))?;
    o_prot.write_string(&self.delegation_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCancelDelegationTokenResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCancelDelegationTokenResp {
  pub status: TStatus,
}

impl TCancelDelegationTokenResp {
  pub fn new(status: TStatus) -> TCancelDelegationTokenResp {
    TCancelDelegationTokenResp {
      status,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCancelDelegationTokenResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCancelDelegationTokenResp.status", &f_1)?;
    let ret = TCancelDelegationTokenResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCancelDelegationTokenResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRenewDelegationTokenReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenewDelegationTokenReq {
  pub session_handle: TSessionHandle,
  pub delegation_token: String,
}

impl TRenewDelegationTokenReq {
  pub fn new(session_handle: TSessionHandle, delegation_token: String) -> TRenewDelegationTokenReq {
    TRenewDelegationTokenReq {
      session_handle,
      delegation_token,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenewDelegationTokenReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionHandle> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSessionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRenewDelegationTokenReq.session_handle", &f_1)?;
    verify_required_field_exists("TRenewDelegationTokenReq.delegation_token", &f_2)?;
    let ret = TRenewDelegationTokenReq {
      session_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      delegation_token: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenewDelegationTokenReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionHandle", TType::Struct, 1))?;
    self.session_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("delegationToken", TType::String, 2))?;
    o_prot.write_string(&self.delegation_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRenewDelegationTokenResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenewDelegationTokenResp {
  pub status: TStatus,
}

impl TRenewDelegationTokenResp {
  pub fn new(status: TStatus) -> TRenewDelegationTokenResp {
    TRenewDelegationTokenResp {
      status,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenewDelegationTokenResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRenewDelegationTokenResp.status", &f_1)?;
    let ret = TRenewDelegationTokenResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenewDelegationTokenResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TProgressUpdateResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TProgressUpdateResp {
  pub header_names: Vec<String>,
  pub rows: Vec<Vec<String>>,
  pub progressed_percentage: OrderedFloat<f64>,
  pub status: TJobExecutionStatus,
  pub footer_summary: String,
  pub start_time: i64,
}

impl TProgressUpdateResp {
  pub fn new(header_names: Vec<String>, rows: Vec<Vec<String>>, progressed_percentage: OrderedFloat<f64>, status: TJobExecutionStatus, footer_summary: String, start_time: i64) -> TProgressUpdateResp {
    TProgressUpdateResp {
      header_names,
      rows,
      progressed_percentage,
      status,
      footer_summary,
      start_time,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TProgressUpdateResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<Vec<Vec<String>>> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    let mut f_4: Option<TJobExecutionStatus> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_29 = i_prot.read_string()?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_30: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_31 = i_prot.read_string()?;
              list_elem_30.push(list_elem_31);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_30);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = TJobExecutionStatus::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TProgressUpdateResp.header_names", &f_1)?;
    verify_required_field_exists("TProgressUpdateResp.rows", &f_2)?;
    verify_required_field_exists("TProgressUpdateResp.progressed_percentage", &f_3)?;
    verify_required_field_exists("TProgressUpdateResp.status", &f_4)?;
    verify_required_field_exists("TProgressUpdateResp.footer_summary", &f_5)?;
    verify_required_field_exists("TProgressUpdateResp.start_time", &f_6)?;
    let ret = TProgressUpdateResp {
      header_names: f_1.expect("auto-generated code should have checked for presence of required fields"),
      rows: f_2.expect("auto-generated code should have checked for presence of required fields"),
      progressed_percentage: f_3.expect("auto-generated code should have checked for presence of required fields"),
      status: f_4.expect("auto-generated code should have checked for presence of required fields"),
      footer_summary: f_5.expect("auto-generated code should have checked for presence of required fields"),
      start_time: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TProgressUpdateResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("headerNames", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.header_names.len() as i32))?;
    for e in &self.header_names {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.rows.len() as i32))?;
    for e in &self.rows {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("progressedPercentage", TType::Double, 3))?;
    o_prot.write_double(self.progressed_percentage.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 4))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("footerSummary", TType::String, 5))?;
    o_prot.write_string(&self.footer_summary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I64, 6))?;
    o_prot.write_i64(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetQueryIdReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetQueryIdReq {
  pub operation_handle: TOperationHandle,
}

impl TGetQueryIdReq {
  pub fn new(operation_handle: TOperationHandle) -> TGetQueryIdReq {
    TGetQueryIdReq {
      operation_handle,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetQueryIdReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOperationHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOperationHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetQueryIdReq.operation_handle", &f_1)?;
    let ret = TGetQueryIdReq {
      operation_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetQueryIdReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("operationHandle", TType::Struct, 1))?;
    self.operation_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetQueryIdResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetQueryIdResp {
  pub query_id: String,
}

impl TGetQueryIdResp {
  pub fn new(query_id: String) -> TGetQueryIdResp {
    TGetQueryIdResp {
      query_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetQueryIdResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetQueryIdResp.query_id", &f_1)?;
    let ret = TGetQueryIdResp {
      query_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetQueryIdResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::String, 1))?;
    o_prot.write_string(&self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub struct ConstPRIMITIVETYPES;
impl ConstPRIMITIVETYPES {
  pub fn const_value() -> BTreeSet<TTypeId> {
    {
      let mut s: BTreeSet<TTypeId> = BTreeSet::new();
      s.insert(
        {
          TTypeId::try_from(0).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(1).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(2).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(3).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(4).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(5).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(6).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(7).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(8).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(9).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(15).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(16).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(17).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(18).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(19).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(20).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(21).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(22).expect("expecting valid const value")
        }
      );
      s
    }
  }
}

pub struct ConstCOMPLEXTYPES;
impl ConstCOMPLEXTYPES {
  pub fn const_value() -> BTreeSet<TTypeId> {
    {
      let mut s: BTreeSet<TTypeId> = BTreeSet::new();
      s.insert(
        {
          TTypeId::try_from(10).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(11).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(12).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(13).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(14).expect("expecting valid const value")
        }
      );
      s
    }
  }
}

pub struct ConstCOLLECTIONTYPES;
impl ConstCOLLECTIONTYPES {
  pub fn const_value() -> BTreeSet<TTypeId> {
    {
      let mut s: BTreeSet<TTypeId> = BTreeSet::new();
      s.insert(
        {
          TTypeId::try_from(10).expect("expecting valid const value")
        }
      );
      s.insert(
        {
          TTypeId::try_from(11).expect("expecting valid const value")
        }
      );
      s
    }
  }
}

pub struct ConstTYPENAMES;
impl ConstTYPENAMES {
  pub fn const_value() -> BTreeMap<TTypeId, String> {
    {
      let mut m: BTreeMap<TTypeId, String> = BTreeMap::new();
      let k = {
        {
          TTypeId::try_from(10).expect("expecting valid const value")
        }
      };
      let v = "ARRAY".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(4).expect("expecting valid const value")
        }
      };
      let v = "BIGINT".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(9).expect("expecting valid const value")
        }
      };
      let v = "BINARY".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(0).expect("expecting valid const value")
        }
      };
      let v = "BOOLEAN".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(19).expect("expecting valid const value")
        }
      };
      let v = "CHAR".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(17).expect("expecting valid const value")
        }
      };
      let v = "DATE".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(15).expect("expecting valid const value")
        }
      };
      let v = "DECIMAL".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(6).expect("expecting valid const value")
        }
      };
      let v = "DOUBLE".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(5).expect("expecting valid const value")
        }
      };
      let v = "FLOAT".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(21).expect("expecting valid const value")
        }
      };
      let v = "INTERVAL_DAY_TIME".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(20).expect("expecting valid const value")
        }
      };
      let v = "INTERVAL_YEAR_MONTH".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(3).expect("expecting valid const value")
        }
      };
      let v = "INT".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(11).expect("expecting valid const value")
        }
      };
      let v = "MAP".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(16).expect("expecting valid const value")
        }
      };
      let v = "NULL".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(2).expect("expecting valid const value")
        }
      };
      let v = "SMALLINT".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(7).expect("expecting valid const value")
        }
      };
      let v = "STRING".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(12).expect("expecting valid const value")
        }
      };
      let v = "STRUCT".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(22).expect("expecting valid const value")
        }
      };
      let v = "TIMESTAMP WITH LOCAL TIME ZONE".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(8).expect("expecting valid const value")
        }
      };
      let v = "TIMESTAMP".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(1).expect("expecting valid const value")
        }
      };
      let v = "TINYINT".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(13).expect("expecting valid const value")
        }
      };
      let v = "UNIONTYPE".to_owned();
      m.insert(k, v);
      let k = {
        {
          TTypeId::try_from(18).expect("expecting valid const value")
        }
      };
      let v = "VARCHAR".to_owned();
      m.insert(k, v);
      m
    }
  }
}

pub const C_H_A_R_A_C_T_E_R_M_A_X_I_M_U_M_L_E_N_G_T_H: &str = "characterMaximumLength";

pub const P_R_E_C_I_S_I_O_N: &str = "precision";

pub const S_C_A_L_E: &str = "scale";

//
// TCLIService service client
//

pub trait TTCLIServiceSyncClient {
  fn open_session(&mut self, req: TOpenSessionReq) -> thrift::Result<TOpenSessionResp>;
  fn close_session(&mut self, req: TCloseSessionReq) -> thrift::Result<TCloseSessionResp>;
  fn get_info(&mut self, req: TGetInfoReq) -> thrift::Result<TGetInfoResp>;
  fn execute_statement(&mut self, req: TExecuteStatementReq) -> thrift::Result<TExecuteStatementResp>;
  fn get_type_info(&mut self, req: TGetTypeInfoReq) -> thrift::Result<TGetTypeInfoResp>;
  fn get_catalogs(&mut self, req: TGetCatalogsReq) -> thrift::Result<TGetCatalogsResp>;
  fn get_schemas(&mut self, req: TGetSchemasReq) -> thrift::Result<TGetSchemasResp>;
  fn get_tables(&mut self, req: TGetTablesReq) -> thrift::Result<TGetTablesResp>;
  fn get_table_types(&mut self, req: TGetTableTypesReq) -> thrift::Result<TGetTableTypesResp>;
  fn get_columns(&mut self, req: TGetColumnsReq) -> thrift::Result<TGetColumnsResp>;
  fn get_functions(&mut self, req: TGetFunctionsReq) -> thrift::Result<TGetFunctionsResp>;
  fn get_primary_keys(&mut self, req: TGetPrimaryKeysReq) -> thrift::Result<TGetPrimaryKeysResp>;
  fn get_cross_reference(&mut self, req: TGetCrossReferenceReq) -> thrift::Result<TGetCrossReferenceResp>;
  fn get_operation_status(&mut self, req: TGetOperationStatusReq) -> thrift::Result<TGetOperationStatusResp>;
  fn cancel_operation(&mut self, req: TCancelOperationReq) -> thrift::Result<TCancelOperationResp>;
  fn close_operation(&mut self, req: TCloseOperationReq) -> thrift::Result<TCloseOperationResp>;
  fn get_result_set_metadata(&mut self, req: TGetResultSetMetadataReq) -> thrift::Result<TGetResultSetMetadataResp>;
  fn fetch_results(&mut self, req: TFetchResultsReq) -> thrift::Result<TFetchResultsResp>;
  fn get_delegation_token(&mut self, req: TGetDelegationTokenReq) -> thrift::Result<TGetDelegationTokenResp>;
  fn cancel_delegation_token(&mut self, req: TCancelDelegationTokenReq) -> thrift::Result<TCancelDelegationTokenResp>;
  fn renew_delegation_token(&mut self, req: TRenewDelegationTokenReq) -> thrift::Result<TRenewDelegationTokenResp>;
  fn get_query_id(&mut self, req: TGetQueryIdReq) -> thrift::Result<TGetQueryIdResp>;
  fn set_client_info(&mut self, req: TSetClientInfoReq) -> thrift::Result<TSetClientInfoResp>;
}

pub trait TTCLIServiceSyncClientMarker {}

pub struct TCLIServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> TCLIServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> TCLIServiceSyncClient<IP, OP> {
    TCLIServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for TCLIServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TTCLIServiceSyncClientMarker for TCLIServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TTCLIServiceSyncClientMarker> TTCLIServiceSyncClient for C {
  fn open_session(&mut self, req: TOpenSessionReq) -> thrift::Result<TOpenSessionResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("OpenSession", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceOpenSessionArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("OpenSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceOpenSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn close_session(&mut self, req: TCloseSessionReq) -> thrift::Result<TCloseSessionResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("CloseSession", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceCloseSessionArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("CloseSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceCloseSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_info(&mut self, req: TGetInfoReq) -> thrift::Result<TGetInfoResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetInfo", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetInfoArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_statement(&mut self, req: TExecuteStatementReq) -> thrift::Result<TExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ExecuteStatement", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceExecuteStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ExecuteStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceExecuteStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_type_info(&mut self, req: TGetTypeInfoReq) -> thrift::Result<TGetTypeInfoResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetTypeInfo", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetTypeInfoArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetTypeInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetTypeInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_catalogs(&mut self, req: TGetCatalogsReq) -> thrift::Result<TGetCatalogsResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetCatalogs", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetCatalogsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetCatalogs", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetCatalogsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_schemas(&mut self, req: TGetSchemasReq) -> thrift::Result<TGetSchemasResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetSchemas", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetSchemasArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetSchemas", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetSchemasResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables(&mut self, req: TGetTablesReq) -> thrift::Result<TGetTablesResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetTables", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetTablesArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetTables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_types(&mut self, req: TGetTableTypesReq) -> thrift::Result<TGetTableTypesResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetTableTypes", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetTableTypesArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetTableTypes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetTableTypesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_columns(&mut self, req: TGetColumnsReq) -> thrift::Result<TGetColumnsResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetColumns", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetColumnsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetColumns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_functions(&mut self, req: TGetFunctionsReq) -> thrift::Result<TGetFunctionsResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetFunctions", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetFunctionsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetFunctions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetFunctionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_primary_keys(&mut self, req: TGetPrimaryKeysReq) -> thrift::Result<TGetPrimaryKeysResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetPrimaryKeys", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetPrimaryKeysArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetPrimaryKeys", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetPrimaryKeysResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_cross_reference(&mut self, req: TGetCrossReferenceReq) -> thrift::Result<TGetCrossReferenceResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetCrossReference", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetCrossReferenceArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetCrossReference", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetCrossReferenceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_operation_status(&mut self, req: TGetOperationStatusReq) -> thrift::Result<TGetOperationStatusResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetOperationStatus", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetOperationStatusArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetOperationStatus", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetOperationStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cancel_operation(&mut self, req: TCancelOperationReq) -> thrift::Result<TCancelOperationResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("CancelOperation", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceCancelOperationArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("CancelOperation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceCancelOperationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn close_operation(&mut self, req: TCloseOperationReq) -> thrift::Result<TCloseOperationResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("CloseOperation", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceCloseOperationArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("CloseOperation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceCloseOperationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_result_set_metadata(&mut self, req: TGetResultSetMetadataReq) -> thrift::Result<TGetResultSetMetadataResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetResultSetMetadata", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetResultSetMetadataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetResultSetMetadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetResultSetMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_results(&mut self, req: TFetchResultsReq) -> thrift::Result<TFetchResultsResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("FetchResults", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceFetchResultsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("FetchResults", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceFetchResultsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_delegation_token(&mut self, req: TGetDelegationTokenReq) -> thrift::Result<TGetDelegationTokenResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetDelegationToken", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetDelegationTokenArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetDelegationToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetDelegationTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cancel_delegation_token(&mut self, req: TCancelDelegationTokenReq) -> thrift::Result<TCancelDelegationTokenResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("CancelDelegationToken", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceCancelDelegationTokenArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("CancelDelegationToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceCancelDelegationTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn renew_delegation_token(&mut self, req: TRenewDelegationTokenReq) -> thrift::Result<TRenewDelegationTokenResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RenewDelegationToken", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceRenewDelegationTokenArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RenewDelegationToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceRenewDelegationTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_query_id(&mut self, req: TGetQueryIdReq) -> thrift::Result<TGetQueryIdResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetQueryId", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceGetQueryIdArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetQueryId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceGetQueryIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_client_info(&mut self, req: TSetClientInfoReq) -> thrift::Result<TSetClientInfoResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SetClientInfo", TMessageType::Call, self.sequence_number());
        let call_args = TCLIServiceSetClientInfoArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SetClientInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TCLIServiceSetClientInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// TCLIService service processor
//

pub trait TCLIServiceSyncHandler {
  fn handle_open_session(&self, req: TOpenSessionReq) -> thrift::Result<TOpenSessionResp>;
  fn handle_close_session(&self, req: TCloseSessionReq) -> thrift::Result<TCloseSessionResp>;
  fn handle_get_info(&self, req: TGetInfoReq) -> thrift::Result<TGetInfoResp>;
  fn handle_execute_statement(&self, req: TExecuteStatementReq) -> thrift::Result<TExecuteStatementResp>;
  fn handle_get_type_info(&self, req: TGetTypeInfoReq) -> thrift::Result<TGetTypeInfoResp>;
  fn handle_get_catalogs(&self, req: TGetCatalogsReq) -> thrift::Result<TGetCatalogsResp>;
  fn handle_get_schemas(&self, req: TGetSchemasReq) -> thrift::Result<TGetSchemasResp>;
  fn handle_get_tables(&self, req: TGetTablesReq) -> thrift::Result<TGetTablesResp>;
  fn handle_get_table_types(&self, req: TGetTableTypesReq) -> thrift::Result<TGetTableTypesResp>;
  fn handle_get_columns(&self, req: TGetColumnsReq) -> thrift::Result<TGetColumnsResp>;
  fn handle_get_functions(&self, req: TGetFunctionsReq) -> thrift::Result<TGetFunctionsResp>;
  fn handle_get_primary_keys(&self, req: TGetPrimaryKeysReq) -> thrift::Result<TGetPrimaryKeysResp>;
  fn handle_get_cross_reference(&self, req: TGetCrossReferenceReq) -> thrift::Result<TGetCrossReferenceResp>;
  fn handle_get_operation_status(&self, req: TGetOperationStatusReq) -> thrift::Result<TGetOperationStatusResp>;
  fn handle_cancel_operation(&self, req: TCancelOperationReq) -> thrift::Result<TCancelOperationResp>;
  fn handle_close_operation(&self, req: TCloseOperationReq) -> thrift::Result<TCloseOperationResp>;
  fn handle_get_result_set_metadata(&self, req: TGetResultSetMetadataReq) -> thrift::Result<TGetResultSetMetadataResp>;
  fn handle_fetch_results(&self, req: TFetchResultsReq) -> thrift::Result<TFetchResultsResp>;
  fn handle_get_delegation_token(&self, req: TGetDelegationTokenReq) -> thrift::Result<TGetDelegationTokenResp>;
  fn handle_cancel_delegation_token(&self, req: TCancelDelegationTokenReq) -> thrift::Result<TCancelDelegationTokenResp>;
  fn handle_renew_delegation_token(&self, req: TRenewDelegationTokenReq) -> thrift::Result<TRenewDelegationTokenResp>;
  fn handle_get_query_id(&self, req: TGetQueryIdReq) -> thrift::Result<TGetQueryIdResp>;
  fn handle_set_client_info(&self, req: TSetClientInfoReq) -> thrift::Result<TSetClientInfoResp>;
}

pub struct TCLIServiceSyncProcessor<H: TCLIServiceSyncHandler> {
  handler: H,
}

impl <H: TCLIServiceSyncHandler> TCLIServiceSyncProcessor<H> {
  pub fn new(handler: H) -> TCLIServiceSyncProcessor<H> {
    TCLIServiceSyncProcessor {
      handler,
    }
  }
  fn process_open_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_open_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_close_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_close_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_execute_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_type_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_type_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_catalogs(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_catalogs(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_schemas(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_schemas(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_types(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_table_types(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_functions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_functions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_primary_keys(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_primary_keys(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_cross_reference(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_cross_reference(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_operation_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_operation_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cancel_operation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_cancel_operation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_close_operation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_close_operation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_result_set_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_result_set_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_results(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_fetch_results(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_delegation_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_delegation_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cancel_delegation_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_cancel_delegation_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_renew_delegation_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_renew_delegation_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_query_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_get_query_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_client_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTCLIServiceProcessFunctions::process_set_client_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TTCLIServiceProcessFunctions;

impl TTCLIServiceProcessFunctions {
  pub fn process_open_session<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceOpenSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_open_session(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("OpenSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceOpenSessionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("OpenSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("OpenSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_close_session<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceCloseSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_close_session(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("CloseSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceCloseSessionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("CloseSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("CloseSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_info<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_info(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetInfoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_statement<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceExecuteStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ExecuteStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceExecuteStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ExecuteStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("ExecuteStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_type_info<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetTypeInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_type_info(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetTypeInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetTypeInfoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetTypeInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetTypeInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_catalogs<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetCatalogsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_catalogs(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetCatalogs", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetCatalogsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetCatalogs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetCatalogs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_schemas<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetSchemasArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_schemas(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetSchemas", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetSchemasResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetSchemas", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetSchemas", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetTables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetTablesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetTables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetTables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_types<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetTableTypesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_types(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetTableTypes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetTableTypesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetTableTypes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetTableTypes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_columns<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_columns(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetColumns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetColumnsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetColumns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetColumns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_functions<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetFunctionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_functions(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetFunctions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetFunctionsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetFunctions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetFunctions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_primary_keys<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetPrimaryKeysArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_primary_keys(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetPrimaryKeys", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetPrimaryKeysResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetPrimaryKeys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetPrimaryKeys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_cross_reference<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetCrossReferenceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_cross_reference(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetCrossReference", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetCrossReferenceResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetCrossReference", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetCrossReference", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_operation_status<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetOperationStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_operation_status(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetOperationStatus", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetOperationStatusResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetOperationStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetOperationStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cancel_operation<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceCancelOperationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cancel_operation(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("CancelOperation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceCancelOperationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("CancelOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("CancelOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_close_operation<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceCloseOperationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_close_operation(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("CloseOperation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceCloseOperationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("CloseOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("CloseOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_result_set_metadata<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetResultSetMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_result_set_metadata(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetResultSetMetadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetResultSetMetadataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetResultSetMetadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetResultSetMetadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_results<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceFetchResultsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_results(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("FetchResults", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceFetchResultsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("FetchResults", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("FetchResults", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_delegation_token<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetDelegationTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_delegation_token(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetDelegationToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetDelegationTokenResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetDelegationToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetDelegationToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cancel_delegation_token<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceCancelDelegationTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cancel_delegation_token(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("CancelDelegationToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceCancelDelegationTokenResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("CancelDelegationToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("CancelDelegationToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_renew_delegation_token<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceRenewDelegationTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_renew_delegation_token(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RenewDelegationToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceRenewDelegationTokenResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RenewDelegationToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("RenewDelegationToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_query_id<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceGetQueryIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_query_id(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetQueryId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceGetQueryIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetQueryId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetQueryId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_client_info<H: TCLIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TCLIServiceSetClientInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_client_info(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SetClientInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TCLIServiceSetClientInfoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SetClientInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SetClientInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: TCLIServiceSyncHandler> TProcessor for TCLIServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "OpenSession" => {
        self.process_open_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "CloseSession" => {
        self.process_close_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetInfo" => {
        self.process_get_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "ExecuteStatement" => {
        self.process_execute_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetTypeInfo" => {
        self.process_get_type_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetCatalogs" => {
        self.process_get_catalogs(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetSchemas" => {
        self.process_get_schemas(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetTables" => {
        self.process_get_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetTableTypes" => {
        self.process_get_table_types(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetColumns" => {
        self.process_get_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetFunctions" => {
        self.process_get_functions(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetPrimaryKeys" => {
        self.process_get_primary_keys(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetCrossReference" => {
        self.process_get_cross_reference(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetOperationStatus" => {
        self.process_get_operation_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "CancelOperation" => {
        self.process_cancel_operation(message_ident.sequence_number, i_prot, o_prot)
      },
      "CloseOperation" => {
        self.process_close_operation(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetResultSetMetadata" => {
        self.process_get_result_set_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "FetchResults" => {
        self.process_fetch_results(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetDelegationToken" => {
        self.process_get_delegation_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "CancelDelegationToken" => {
        self.process_cancel_delegation_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "RenewDelegationToken" => {
        self.process_renew_delegation_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetQueryId" => {
        self.process_get_query_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "SetClientInfo" => {
        self.process_set_client_info(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// TCLIServiceOpenSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceOpenSessionArgs {
  req: TOpenSessionReq,
}

impl TCLIServiceOpenSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceOpenSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOpenSessionReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOpenSessionReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceOpenSessionArgs.req", &f_1)?;
    let ret = TCLIServiceOpenSessionArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OpenSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceOpenSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceOpenSessionResult {
  result_value: Option<TOpenSessionResp>,
}

impl TCLIServiceOpenSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceOpenSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TOpenSessionResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TOpenSessionResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceOpenSessionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceOpenSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TOpenSessionResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceOpenSession"
          )
        )
      )
    }
  }
}

//
// TCLIServiceCloseSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceCloseSessionArgs {
  req: TCloseSessionReq,
}

impl TCLIServiceCloseSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceCloseSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TCloseSessionReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TCloseSessionReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceCloseSessionArgs.req", &f_1)?;
    let ret = TCLIServiceCloseSessionArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CloseSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceCloseSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceCloseSessionResult {
  result_value: Option<TCloseSessionResp>,
}

impl TCLIServiceCloseSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceCloseSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TCloseSessionResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TCloseSessionResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceCloseSessionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceCloseSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TCloseSessionResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceCloseSession"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetInfoArgs {
  req: TGetInfoReq,
}

impl TCLIServiceGetInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetInfoReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetInfoReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetInfoArgs.req", &f_1)?;
    let ret = TCLIServiceGetInfoArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetInfoResult {
  result_value: Option<TGetInfoResp>,
}

impl TCLIServiceGetInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetInfoResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetInfoResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetInfoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetInfoResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetInfo"
          )
        )
      )
    }
  }
}

//
// TCLIServiceExecuteStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceExecuteStatementArgs {
  req: TExecuteStatementReq,
}

impl TCLIServiceExecuteStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceExecuteStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TExecuteStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TExecuteStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceExecuteStatementArgs.req", &f_1)?;
    let ret = TCLIServiceExecuteStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExecuteStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceExecuteStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceExecuteStatementResult {
  result_value: Option<TExecuteStatementResp>,
}

impl TCLIServiceExecuteStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceExecuteStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceExecuteStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceExecuteStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceExecuteStatement"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetTypeInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetTypeInfoArgs {
  req: TGetTypeInfoReq,
}

impl TCLIServiceGetTypeInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetTypeInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetTypeInfoReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetTypeInfoReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetTypeInfoArgs.req", &f_1)?;
    let ret = TCLIServiceGetTypeInfoArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTypeInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetTypeInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetTypeInfoResult {
  result_value: Option<TGetTypeInfoResp>,
}

impl TCLIServiceGetTypeInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetTypeInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetTypeInfoResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetTypeInfoResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetTypeInfoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetTypeInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetTypeInfoResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetTypeInfo"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetCatalogsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetCatalogsArgs {
  req: TGetCatalogsReq,
}

impl TCLIServiceGetCatalogsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetCatalogsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetCatalogsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetCatalogsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetCatalogsArgs.req", &f_1)?;
    let ret = TCLIServiceGetCatalogsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCatalogs_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetCatalogsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetCatalogsResult {
  result_value: Option<TGetCatalogsResp>,
}

impl TCLIServiceGetCatalogsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetCatalogsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetCatalogsResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetCatalogsResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetCatalogsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetCatalogsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetCatalogsResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetCatalogs"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetSchemasArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetSchemasArgs {
  req: TGetSchemasReq,
}

impl TCLIServiceGetSchemasArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetSchemasArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetSchemasReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetSchemasReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetSchemasArgs.req", &f_1)?;
    let ret = TCLIServiceGetSchemasArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetSchemas_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetSchemasResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetSchemasResult {
  result_value: Option<TGetSchemasResp>,
}

impl TCLIServiceGetSchemasResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetSchemasResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetSchemasResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetSchemasResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetSchemasResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetSchemasResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetSchemasResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetSchemas"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetTablesArgs {
  req: TGetTablesReq,
}

impl TCLIServiceGetTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetTablesReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetTablesReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetTablesArgs.req", &f_1)?;
    let ret = TCLIServiceGetTablesArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetTablesResult {
  result_value: Option<TGetTablesResp>,
}

impl TCLIServiceGetTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetTablesResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetTablesResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetTablesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetTablesResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetTables"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetTableTypesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetTableTypesArgs {
  req: TGetTableTypesReq,
}

impl TCLIServiceGetTableTypesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetTableTypesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetTableTypesReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetTableTypesReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetTableTypesArgs.req", &f_1)?;
    let ret = TCLIServiceGetTableTypesArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTableTypes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetTableTypesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetTableTypesResult {
  result_value: Option<TGetTableTypesResp>,
}

impl TCLIServiceGetTableTypesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetTableTypesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetTableTypesResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetTableTypesResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetTableTypesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetTableTypesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetTableTypesResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetTableTypes"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetColumnsArgs {
  req: TGetColumnsReq,
}

impl TCLIServiceGetColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetColumnsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetColumnsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetColumnsArgs.req", &f_1)?;
    let ret = TCLIServiceGetColumnsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetColumns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetColumnsResult {
  result_value: Option<TGetColumnsResp>,
}

impl TCLIServiceGetColumnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetColumnsResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetColumnsResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetColumnsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetColumnsResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetColumns"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetFunctionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetFunctionsArgs {
  req: TGetFunctionsReq,
}

impl TCLIServiceGetFunctionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetFunctionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetFunctionsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetFunctionsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetFunctionsArgs.req", &f_1)?;
    let ret = TCLIServiceGetFunctionsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetFunctions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetFunctionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetFunctionsResult {
  result_value: Option<TGetFunctionsResp>,
}

impl TCLIServiceGetFunctionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetFunctionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetFunctionsResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetFunctionsResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetFunctionsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetFunctionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetFunctionsResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetFunctions"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetPrimaryKeysArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetPrimaryKeysArgs {
  req: TGetPrimaryKeysReq,
}

impl TCLIServiceGetPrimaryKeysArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetPrimaryKeysArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetPrimaryKeysReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetPrimaryKeysReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetPrimaryKeysArgs.req", &f_1)?;
    let ret = TCLIServiceGetPrimaryKeysArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetPrimaryKeys_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetPrimaryKeysResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetPrimaryKeysResult {
  result_value: Option<TGetPrimaryKeysResp>,
}

impl TCLIServiceGetPrimaryKeysResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetPrimaryKeysResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetPrimaryKeysResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetPrimaryKeysResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetPrimaryKeysResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetPrimaryKeysResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetPrimaryKeysResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetPrimaryKeys"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetCrossReferenceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetCrossReferenceArgs {
  req: TGetCrossReferenceReq,
}

impl TCLIServiceGetCrossReferenceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetCrossReferenceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetCrossReferenceReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetCrossReferenceReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetCrossReferenceArgs.req", &f_1)?;
    let ret = TCLIServiceGetCrossReferenceArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCrossReference_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetCrossReferenceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetCrossReferenceResult {
  result_value: Option<TGetCrossReferenceResp>,
}

impl TCLIServiceGetCrossReferenceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetCrossReferenceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetCrossReferenceResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetCrossReferenceResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetCrossReferenceResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetCrossReferenceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetCrossReferenceResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetCrossReference"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetOperationStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetOperationStatusArgs {
  req: TGetOperationStatusReq,
}

impl TCLIServiceGetOperationStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetOperationStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetOperationStatusReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetOperationStatusReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetOperationStatusArgs.req", &f_1)?;
    let ret = TCLIServiceGetOperationStatusArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetOperationStatus_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetOperationStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetOperationStatusResult {
  result_value: Option<TGetOperationStatusResp>,
}

impl TCLIServiceGetOperationStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetOperationStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetOperationStatusResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetOperationStatusResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetOperationStatusResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetOperationStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetOperationStatusResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetOperationStatus"
          )
        )
      )
    }
  }
}

//
// TCLIServiceCancelOperationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceCancelOperationArgs {
  req: TCancelOperationReq,
}

impl TCLIServiceCancelOperationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceCancelOperationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TCancelOperationReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TCancelOperationReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceCancelOperationArgs.req", &f_1)?;
    let ret = TCLIServiceCancelOperationArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CancelOperation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceCancelOperationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceCancelOperationResult {
  result_value: Option<TCancelOperationResp>,
}

impl TCLIServiceCancelOperationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceCancelOperationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TCancelOperationResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TCancelOperationResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceCancelOperationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceCancelOperationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TCancelOperationResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceCancelOperation"
          )
        )
      )
    }
  }
}

//
// TCLIServiceCloseOperationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceCloseOperationArgs {
  req: TCloseOperationReq,
}

impl TCLIServiceCloseOperationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceCloseOperationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TCloseOperationReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TCloseOperationReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceCloseOperationArgs.req", &f_1)?;
    let ret = TCLIServiceCloseOperationArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CloseOperation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceCloseOperationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceCloseOperationResult {
  result_value: Option<TCloseOperationResp>,
}

impl TCLIServiceCloseOperationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceCloseOperationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TCloseOperationResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TCloseOperationResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceCloseOperationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceCloseOperationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TCloseOperationResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceCloseOperation"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetResultSetMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetResultSetMetadataArgs {
  req: TGetResultSetMetadataReq,
}

impl TCLIServiceGetResultSetMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetResultSetMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetResultSetMetadataReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetResultSetMetadataReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetResultSetMetadataArgs.req", &f_1)?;
    let ret = TCLIServiceGetResultSetMetadataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetResultSetMetadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetResultSetMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetResultSetMetadataResult {
  result_value: Option<TGetResultSetMetadataResp>,
}

impl TCLIServiceGetResultSetMetadataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetResultSetMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetResultSetMetadataResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetResultSetMetadataResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetResultSetMetadataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetResultSetMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetResultSetMetadataResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetSetMetadataResult"
          )
        )
      )
    }
  }
}

//
// TCLIServiceFetchResultsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceFetchResultsArgs {
  req: TFetchResultsReq,
}

impl TCLIServiceFetchResultsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceFetchResultsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TFetchResultsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TFetchResultsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceFetchResultsArgs.req", &f_1)?;
    let ret = TCLIServiceFetchResultsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FetchResults_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceFetchResultsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceFetchResultsResult {
  result_value: Option<TFetchResultsResp>,
}

impl TCLIServiceFetchResultsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceFetchResultsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TFetchResultsResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TFetchResultsResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceFetchResultsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceFetchResultsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TFetchResultsResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceFetchsResult"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetDelegationTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetDelegationTokenArgs {
  req: TGetDelegationTokenReq,
}

impl TCLIServiceGetDelegationTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetDelegationTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetDelegationTokenReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetDelegationTokenReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetDelegationTokenArgs.req", &f_1)?;
    let ret = TCLIServiceGetDelegationTokenArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetDelegationToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetDelegationTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetDelegationTokenResult {
  result_value: Option<TGetDelegationTokenResp>,
}

impl TCLIServiceGetDelegationTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetDelegationTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetDelegationTokenResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetDelegationTokenResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetDelegationTokenResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetDelegationTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetDelegationTokenResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetDelegationToken"
          )
        )
      )
    }
  }
}

//
// TCLIServiceCancelDelegationTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceCancelDelegationTokenArgs {
  req: TCancelDelegationTokenReq,
}

impl TCLIServiceCancelDelegationTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceCancelDelegationTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TCancelDelegationTokenReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TCancelDelegationTokenReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceCancelDelegationTokenArgs.req", &f_1)?;
    let ret = TCLIServiceCancelDelegationTokenArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CancelDelegationToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceCancelDelegationTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceCancelDelegationTokenResult {
  result_value: Option<TCancelDelegationTokenResp>,
}

impl TCLIServiceCancelDelegationTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceCancelDelegationTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TCancelDelegationTokenResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TCancelDelegationTokenResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceCancelDelegationTokenResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceCancelDelegationTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TCancelDelegationTokenResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceCancelDelegationToken"
          )
        )
      )
    }
  }
}

//
// TCLIServiceRenewDelegationTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceRenewDelegationTokenArgs {
  req: TRenewDelegationTokenReq,
}

impl TCLIServiceRenewDelegationTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceRenewDelegationTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRenewDelegationTokenReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TRenewDelegationTokenReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceRenewDelegationTokenArgs.req", &f_1)?;
    let ret = TCLIServiceRenewDelegationTokenArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RenewDelegationToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceRenewDelegationTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceRenewDelegationTokenResult {
  result_value: Option<TRenewDelegationTokenResp>,
}

impl TCLIServiceRenewDelegationTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceRenewDelegationTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRenewDelegationTokenResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TRenewDelegationTokenResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceRenewDelegationTokenResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceRenewDelegationTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRenewDelegationTokenResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceRenewDelegationToken"
          )
        )
      )
    }
  }
}

//
// TCLIServiceGetQueryIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetQueryIdArgs {
  req: TGetQueryIdReq,
}

impl TCLIServiceGetQueryIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetQueryIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TGetQueryIdReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TGetQueryIdReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceGetQueryIdArgs.req", &f_1)?;
    let ret = TCLIServiceGetQueryIdArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetQueryId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceGetQueryIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceGetQueryIdResult {
  result_value: Option<TGetQueryIdResp>,
}

impl TCLIServiceGetQueryIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceGetQueryIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TGetQueryIdResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TGetQueryIdResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceGetQueryIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceGetQueryIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TGetQueryIdResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceGetQueryId"
          )
        )
      )
    }
  }
}

//
// TCLIServiceSetClientInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceSetClientInfoArgs {
  req: TSetClientInfoReq,
}

impl TCLIServiceSetClientInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceSetClientInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSetClientInfoReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSetClientInfoReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCLIServiceSetClientInfoArgs.req", &f_1)?;
    let ret = TCLIServiceSetClientInfoArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetClientInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCLIServiceSetClientInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TCLIServiceSetClientInfoResult {
  result_value: Option<TSetClientInfoResp>,
}

impl TCLIServiceSetClientInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCLIServiceSetClientInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSetClientInfoResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSetClientInfoResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCLIServiceSetClientInfoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCLIServiceSetClientInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSetClientInfoResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TCLIServiceSetClientInfo"
          )
        )
      )
    }
  }
}

